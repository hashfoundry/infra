# 170. –ö–∞–∫ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å cross-cloud disaster recovery?

## üéØ **–ß—Ç–æ —Ç–∞–∫–æ–µ cross-cloud disaster recovery?**

**Cross-cloud disaster recovery** ‚Äî —ç—Ç–æ –∫–æ–º–ø–ª–µ–∫—Å–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ—Å—Ç–∏ –±–∏–∑–Ω–µ—Å–∞ —á–µ—Ä–µ–∑ —Ä–µ–ø–ª–∏–∫–∞—Ü–∏—é –¥–∞–Ω–Ω—ã—Ö, –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π –∏ –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä—ã –º–µ–∂–¥—É —Ä–∞–∑–ª–∏—á–Ω—ã–º–∏ cloud providers, –≤–∫–ª—é—á–∞—é—â–∞—è automated failover, multi-cloud backup, network connectivity, configuration synchronization, DNS failover –∏ automated recovery procedures –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç –æ—Ç–∫–∞–∑–∞ —Ü–µ–ª–æ–≥–æ –æ–±–ª–∞—á–Ω–æ–≥–æ –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞.

## üèóÔ∏è **–û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã cross-cloud DR:**

### **1. Multi-Cloud Architecture**
- **Primary Cloud**: –û—Å–Ω–æ–≤–Ω–æ–π cloud provider (AWS, Azure, GCP)
- **Secondary Cloud**: –†–µ–∑–µ—Ä–≤–Ω—ã–π cloud provider –¥–ª—è failover
- **Tertiary Cloud**: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π cloud –¥–ª—è –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
- **Hybrid Connectivity**: VPN, direct connect, SD-WAN –º–µ–∂–¥—É clouds

### **2. Data Replication Layers**
- **Application Data**: Database replication, object storage sync
- **Configuration Data**: Kubernetes manifests, secrets, configmaps
- **Infrastructure State**: Terraform state, cluster configurations
- **Backup Data**: Cross-cloud backup replication –∏ versioning

### **3. Orchestration Components**
- **Failover Automation**: Automated detection –∏ switching
- **DNS Management**: Global load balancing –∏ health checks
- **Network Routing**: Traffic steering –∏ connectivity management
- **Recovery Procedures**: Automated rollback –∏ data consistency

## üìä **–ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–µ—Ä—ã –∏–∑ –≤–∞—à–µ–≥–æ HA –∫–ª–∞—Å—Ç–µ—Ä–∞:**

### **1. –ê–Ω–∞–ª–∏–∑ —Ç–µ–∫—É—â–µ–π cross-cloud –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏:**
```bash
# –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–µ–∫—É—â–µ–≥–æ cloud provider
kubectl get nodes -o wide | head -5
doctl kubernetes cluster list
kubectl get storageclass -o custom-columns=NAME:.metadata.name,PROVISIONER:.provisioner

# –ê–Ω–∞–ª–∏–∑ backup locations
velero backup-location get -o custom-columns=NAME:.metadata.name,PROVIDER:.spec.provider,BUCKET:.spec.objectStorage.bucket,STATUS:.status.phase

# –ü—Ä–æ–≤–µ—Ä–∫–∞ network connectivity
ping -c 3 8.8.8.8  # Google DNS
ping -c 3 1.1.1.1  # Cloudflare DNS
curl -I https://api.digitalocean.com/v2/account 2>/dev/null | head -1

# –ê–Ω–∞–ª–∏–∑ cross-region latency
for region in fra1 ams3 lon1; do
  echo "Testing latency to $region:"
  curl -w "Connect: %{time_connect}s, Total: %{time_total}s\n" -o /dev/null -s https://$region.digitalocean.com/
done
```

### **2. –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ cross-cloud –ø—Ä–æ–±–ª–µ–º:**
```bash
# –ü—Ä–æ–≤–µ—Ä–∫–∞ DNS failover –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏
dig +short app.hashfoundry.local
nslookup app.hashfoundry.local 8.8.8.8

# –ê–Ω–∞–ª–∏–∑ backup replication status
velero backup get -o json | jq -r '.items[] | "\(.metadata.name): \(.spec.storageLocation) (\(.status.phase))"' | tail -10

# –ü—Ä–æ–≤–µ—Ä–∫–∞ cross-cloud network connectivity
kubectl get pods -n kube-system -l k8s-app=kube-dns -o wide
kubectl exec -n kube-system $(kubectl get pods -n kube-system -l k8s-app=kube-dns -o name | head -1) -- nslookup kubernetes.default

# –ê–Ω–∞–ª–∏–∑ storage replication
kubectl get pv -o custom-columns=NAME:.metadata.name,STORAGECLASS:.spec.storageClassName,STATUS:.status.phase,CLAIM:.spec.claimRef.name
```

### **3. –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ cross-cloud –º–µ—Ç—Ä–∏–∫:**
```bash
# –ü—Ä–æ–≤–µ—Ä–∫–∞ cluster health across regions
kubectl top nodes | head -5
kubectl get componentstatuses

# –ê–Ω–∞–ª–∏–∑ backup distribution
velero backup get -o json | jq -r 'group_by(.spec.storageLocation) | map({location: .[0].spec.storageLocation, count: length}) | .[]'

# –ü—Ä–æ–≤–µ—Ä–∫–∞ application readiness
kubectl get deployments --all-namespaces -o custom-columns=NAMESPACE:.metadata.namespace,NAME:.metadata.name,READY:.status.readyReplicas,AVAILABLE:.status.availableReplicas | grep -v "0/"
```

## üîÑ **–î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è comprehensive cross-cloud DR:**

### **1. –°–æ–∑–¥–∞–Ω–∏–µ multi-cloud infrastructure framework:**
```bash
# –°–æ–∑–¥–∞—Ç—å —Å–∫—Ä–∏–ø—Ç cross-cloud-dr-manager.sh
cat << 'EOF' > cross-cloud-dr-manager.sh
#!/bin/bash

echo "üåê Comprehensive Cross-Cloud Disaster Recovery Manager"
echo "===================================================="

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
PRIMARY_CLOUD="digitalocean"
SECONDARY_CLOUD="aws"
TERTIARY_CLOUD="azure"
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
DR_LOG="/var/log/cross-cloud-dr-$TIMESTAMP.log"

# Cloud configurations
declare -A CLOUD_CONFIG=(
    ["digitalocean"]="fra1:hashfoundry-primary"
    ["aws"]="eu-central-1:hashfoundry-secondary"
    ["azure"]="westeurope:hashfoundry-tertiary"
)

# –§—É–Ω–∫—Ü–∏—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a $DR_LOG
}

# –§—É–Ω–∫—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞ multi-cloud readiness
analyze_multi_cloud_readiness() {
    log "üîç –ê–Ω–∞–ª–∏–∑ multi-cloud readiness"
    
    local readiness_report="/tmp/multi-cloud-readiness-$TIMESTAMP.json"
    
    # Comprehensive readiness assessment
    cat > $readiness_report << READINESS_ANALYSIS_EOF
{
  "analysis_timestamp": "$(date -Iseconds)",
  "primary_cluster": "$(kubectl config current-context)",
  "multi_cloud_readiness": {
    "infrastructure_status": {
      "primary_cluster": {
        "provider": "$PRIMARY_CLOUD",
        "region": "$(kubectl get nodes -o json | jq -r '.items[0].metadata.labels["topology.kubernetes.io/region"] // "unknown"')",
        "nodes_ready": $(kubectl get nodes --no-headers | grep Ready | wc -l),
        "nodes_total": $(kubectl get nodes --no-headers | wc -l),
        "api_server_healthy": $(kubectl cluster-info &>/dev/null && echo "true" || echo "false")
      },
      "storage_locations": {
$(velero backup-location get -o json | jq -r '
    .items[] | 
    {
      name: .metadata.name,
      provider: .spec.provider,
      bucket: .spec.objectStorage.bucket,
      region: .spec.config.region // "unknown",
      status: .status.phase
    } | 
    "        \"\(.name)\": {\"provider\": \"\(.provider)\", \"bucket\": \"\(.bucket)\", \"region\": \"\(.region)\", \"status\": \"\(.status)\"}"
' | paste -sd, -)
      }
    },
    "backup_replication": {
      "total_backups": $(velero backup get -o json | jq '.items | length'),
      "backup_distribution": {
$(velero backup get -o json | jq -r '
    group_by(.spec.storageLocation) | 
    map({
      location: .[0].spec.storageLocation,
      count: length,
      latest_backup: ([.[].metadata.creationTimestamp] | max),
      oldest_backup: ([.[].metadata.creationTimestamp] | min)
    })[] | 
    "        \"\(.location)\": {\"count\": \(.count), \"latest\": \"\(.latest_backup)\", \"oldest\": \"\(.oldest_backup)\"}"
' | paste -sd, -)
      }
    },
    "network_connectivity": {
      "dns_resolution": {
        "google_dns": "$(dig +short @8.8.8.8 google.com | head -1 | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' && echo "ok" || echo "failed")",
        "cloudflare_dns": "$(dig +short @1.1.1.1 cloudflare.com | head -1 | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' && echo "ok" || echo "failed")"
      },
      "external_connectivity": {
        "digitalocean_api": "$(curl -s -o /dev/null -w "%{http_code}" https://api.digitalocean.com/v2/account | grep -q "200\|401" && echo "ok" || echo "failed")",
        "aws_api": "$(curl -s -o /dev/null -w "%{http_code}" https://ec2.amazonaws.com/ | grep -q "200\|403" && echo "ok" || echo "failed")",
        "azure_api": "$(curl -s -o /dev/null -w "%{http_code}" https://management.azure.com/ | grep -q "200\|401" && echo "ok" || echo "failed")"
      }
    }
  },
  "readiness_score": {
    "infrastructure": "$(kubectl get nodes --no-headers | grep Ready | wc -l)/$(kubectl get nodes --no-headers | wc -l)",
    "backup_locations": $(velero backup-location get -o json | jq '[.items[] | select(.status.phase == "Available")] | length'),
    "network_health": "$(curl -s -o /dev/null -w "%{http_code}" https://api.digitalocean.com/v2/account | grep -q "200\|401" && echo "healthy" || echo "degraded")"
  }
}
READINESS_ANALYSIS_EOF
    
    log "üìÑ Multi-cloud readiness analysis: $readiness_report"
    
    # –ö—Ä–∞—Ç–∫–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    local ready_nodes=$(kubectl get nodes --no-headers | grep Ready | wc -l)
    local total_nodes=$(kubectl get nodes --no-headers | wc -l)
    local backup_locations=$(velero backup-location get -o json | jq '.items | length')
    local available_locations=$(velero backup-location get -o json | jq '[.items[] | select(.status.phase == "Available")] | length')
    
    log "üåê Multi-cloud —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:"
    log "  üñ•Ô∏è –ì–æ—Ç–æ–≤—ã—Ö —É–∑–ª–æ–≤: $ready_nodes/$total_nodes"
    log "  üíæ Backup locations: $available_locations/$backup_locations –¥–æ—Å—Ç—É–ø–Ω—ã"
    log "  ‚òÅÔ∏è Primary cloud: $PRIMARY_CLOUD"
    
    return 0
}

# –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è cross-cloud backup strategy
create_cross_cloud_backup_strategy() {
    log "üì¶ –°–æ–∑–¥–∞–Ω–∏–µ cross-cloud backup strategy"
    
    # –°–æ–∑–¥–∞–Ω–∏–µ backup storage locations –¥–ª—è —Ä–∞–∑–Ω—ã—Ö clouds
    kubectl apply -f - << CROSS_CLOUD_STORAGE_EOF
# DigitalOcean Primary Storage
apiVersion: velero.io/v1
kind: BackupStorageLocation
metadata:
  name: digitalocean-primary
  namespace: velero
  labels:
    cloud-provider: "digitalocean"
    dr-tier: "primary"
spec:
  provider: aws
  objectStorage:
    bucket: hashfoundry-backup-primary
    prefix: digitalocean-primary
  config:
    region: fra1
    s3ForcePathStyle: "true"
    s3Url: https://fra1.digitaloceanspaces.com
  accessMode: ReadWrite
---
# AWS Secondary Storage
apiVersion: velero.io/v1
kind: BackupStorageLocation
metadata:
  name: aws-secondary
  namespace: velero
  labels:
    cloud-provider: "aws"
    dr-tier: "secondary"
spec:
  provider: aws
  objectStorage:
    bucket: hashfoundry-backup-secondary
    prefix: aws-secondary
  config:
    region: eu-central-1
    serverSideEncryption: AES256
  accessMode: ReadWrite
---
# Azure Tertiary Storage
apiVersion: velero.io/v1
kind: BackupStorageLocation
metadata:
  name: azure-tertiary
  namespace: velero
  labels:
    cloud-provider: "azure"
    dr-tier: "tertiary"
spec:
  provider: azure
  objectStorage:
    bucket: hashfoundry-backup-tertiary
    prefix: azure-tertiary
  config:
    resourceGroup: hashfoundry-dr-rg
    storageAccount: hashfoundrydrbackup
    subscriptionId: "your-azure-subscription-id"
  accessMode: ReadWrite
CROSS_CLOUD_STORAGE_EOF
    
    # –°–æ–∑–¥–∞–Ω–∏–µ cross-cloud backup schedules
    kubectl apply -f - << CROSS_CLOUD_SCHEDULES_EOF
# Primary backup schedule
apiVersion: velero.io/v1
kind: Schedule
metadata:
  name: cross-cloud-primary-backup
  namespace: velero
  labels:
    backup-tier: "primary"
spec:
  schedule: "0 2 * * *"  # Daily at 2 AM
  template:
    storageLocation: digitalocean-primary
    includedNamespaces:
    - production
    - staging
    - monitoring
    excludedNamespaces:
    - kube-system
    - velero
    labels:
      backup-type: "cross-cloud-primary"
      retention-policy: "30-days"
    ttl: 720h  # 30 days
---
# Secondary backup schedule (replication)
apiVersion: velero.io/v1
kind: Schedule
metadata:
  name: cross-cloud-secondary-backup
  namespace: velero
  labels:
    backup-tier: "secondary"
spec:
  schedule: "0 4 * * *"  # Daily at 4 AM (2 hours after primary)
  template:
    storageLocation: aws-secondary
    includedNamespaces:
    - production
    - staging
    excludedNamespaces:
    - kube-system
    - velero
    labels:
      backup-type: "cross-cloud-secondary"
      retention-policy: "90-days"
    ttl: 2160h  # 90 days
---
# Tertiary backup schedule (long-term)
apiVersion: velero.io/v1
kind: Schedule
metadata:
  name: cross-cloud-tertiary-backup
  namespace: velero
  labels:
    backup-tier: "tertiary"
spec:
  schedule: "0 6 0 * *"  # Weekly on Sunday at 6 AM
  template:
    storageLocation: azure-tertiary
    includedNamespaces:
    - production
    excludedNamespaces:
    - kube-system
    - velero
    - staging
    labels:
      backup-type: "cross-cloud-tertiary"
      retention-policy: "1-year"
    ttl: 8760h  # 1 year
CROSS_CLOUD_SCHEDULES_EOF
    
    log "‚úÖ Cross-cloud backup strategy —Å–æ–∑–¥–∞–Ω–∞"
}

# –§—É–Ω–∫—Ü–∏—è automated cross-cloud replication
execute_cross_cloud_replication() {
    log "üîÑ –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ cross-cloud replication"
    
    local replication_count=0
    local failed_replications=0
    
    # –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö backup –∏–∑ primary location
    local primary_backups=$(velero backup get -l backup-type=cross-cloud-primary -o json | \
        jq -r --arg since "$(date -d '24 hours ago' -u +%Y-%m-%dT%H:%M:%SZ)" \
        '.items[] | select(.metadata.creationTimestamp > $since) | .metadata.name')
    
    for backup_name in $primary_backups; do
        if [ -n "$backup_name" ]; then
            log "üì¶ –†–µ–ø–ª–∏–∫–∞—Ü–∏—è backup: $backup_name"
            
            # –†–µ–ø–ª–∏–∫–∞—Ü–∏—è –≤ AWS secondary
            if replicate_backup_to_aws "$backup_name"; then
                log "‚úÖ AWS replication —É—Å–ø–µ—à–Ω–∞: $backup_name"
                replication_count=$((replication_count + 1))
            else
                log "‚ùå AWS replication –Ω–µ—É—Å–ø–µ—à–Ω–∞: $backup_name"
                failed_replications=$((failed_replications + 1))
            fi
            
            # –†–µ–ø–ª–∏–∫–∞—Ü–∏—è –≤ Azure tertiary (—Ç–æ–ª—å–∫–æ production)
            if echo "$backup_name" | grep -q "production"; then
                if replicate_backup_to_azure "$backup_name"; then
                    log "‚úÖ Azure replication —É—Å–ø–µ—à–Ω–∞: $backup_name"
                    replication_count=$((replication_count + 1))
                else
                    log "‚ùå Azure replication –Ω–µ—É—Å–ø–µ—à–Ω–∞: $backup_name"
                    failed_replications=$((failed_replications + 1))
                fi
            fi
        fi
    done
    
    log "üìä Cross-cloud replication –∑–∞–≤–µ—Ä—à–µ–Ω–∞:"
    log "  ‚úÖ –£—Å–ø–µ—à–Ω—ã—Ö —Ä–µ–ø–ª–∏–∫–∞—Ü–∏–π: $replication_count"
    log "  ‚ùå –ù–µ—É—Å–ø–µ—à–Ω—ã—Ö —Ä–µ–ø–ª–∏–∫–∞—Ü–∏–π: $failed_replications"
    
    # –°–æ–∑–¥–∞–Ω–∏–µ replication report
    create_replication_report "$replication_count" "$failed_replications"
    
    return $failed_replications
}

# –§—É–Ω–∫—Ü–∏—è —Ä–µ–ø–ª–∏–∫–∞—Ü–∏–∏ –≤ AWS
replicate_backup_to_aws() {
    local backup_name=$1
    
    log "‚òÅÔ∏è –†–µ–ø–ª–∏–∫–∞—Ü–∏—è –≤ AWS: $backup_name"
    
    # –°–æ–∑–¥–∞–Ω–∏–µ backup –≤ AWS location
    velero backup create ${backup_name}-aws-replica \
        --from-backup $backup_name \
        --storage-location aws-secondary \
        --labels "replicated-from=digitalocean,original-backup=$backup_name" \
        --wait --timeout 30m
    
    local exit_code=$?
    
    if [ $exit_code -eq 0 ]; then
        # –°–æ–∑–¥–∞–Ω–∏–µ audit –∑–∞–ø–∏—Å–∏
        cat >> /var/log/cross-cloud-replication.audit << AUDIT_EOF
{
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "action": "backup_replication",
  "source_cloud": "digitalocean",
  "target_cloud": "aws",
  "original_backup": "$backup_name",
  "replica_backup": "${backup_name}-aws-replica",
  "status": "success"
}
AUDIT_EOF
        return 0
    else
        log "‚ùå –û—à–∏–±–∫–∞ —Ä–µ–ø–ª–∏–∫–∞—Ü–∏–∏ –≤ AWS: $backup_name"
        return 1
    fi
}

# –§—É–Ω–∫—Ü–∏—è —Ä–µ–ø–ª–∏–∫–∞—Ü–∏–∏ –≤ Azure
replicate_backup_to_azure() {
    local backup_name=$1
    
    log "‚òÅÔ∏è –†–µ–ø–ª–∏–∫–∞—Ü–∏—è –≤ Azure: $backup_name"
    
    # –°–æ–∑–¥–∞–Ω–∏–µ backup –≤ Azure location
    velero backup create ${backup_name}-azure-replica \
        --from-backup $backup_name \
        --storage-location azure-tertiary \
        --labels "replicated-from=digitalocean,original-backup=$backup_name,tier=long-term" \
        --wait --timeout 45m
    
    local exit_code=$?
    
    if [ $exit_code -eq 0 ]; then
        # –°–æ–∑–¥–∞–Ω–∏–µ audit –∑–∞–ø–∏—Å–∏
        cat >> /var/log/cross-cloud-replication.audit << AUDIT_EOF
{
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "action": "backup_replication",
  "source_cloud": "digitalocean",
  "target_cloud": "azure",
  "original_backup": "$backup_name",
  "replica_backup": "${backup_name}-azure-replica",
  "status": "success"
}
AUDIT_EOF
        return 0
    else
        log "‚ùå –û—à–∏–±–∫–∞ —Ä–µ–ø–ª–∏–∫–∞—Ü–∏–∏ –≤ Azure: $backup_name"
        return 1
    fi
}

# –§—É–Ω–∫—Ü–∏—è automated failover detection
monitor_primary_cloud_health() {
    log "üè• –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ health primary cloud"
    
    local health_checks=0
    local failed_checks=0
    local failover_threshold=3
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ API server –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏
    if kubectl cluster-info &>/dev/null; then
        log "‚úÖ Kubernetes API server –¥–æ—Å—Ç—É–ø–µ–Ω"
        health_checks=$((health_checks + 1))
    else
        log "‚ùå Kubernetes API server –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω"
        failed_checks=$((failed_checks + 1))
    fi
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ nodes –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏
    local ready_nodes=$(kubectl get nodes --no-headers | grep Ready | wc -l)
    local total_nodes=$(kubectl get nodes --no-headers | wc -l)
    
    if [ $ready_nodes -eq $total_nodes ] && [ $total_nodes -gt 0 ]; then
        log "‚úÖ –í—Å–µ —É–∑–ª—ã –≥–æ—Ç–æ–≤—ã ($ready_nodes/$total_nodes)"
        health_checks=$((health_checks + 1))
    else
        log "‚ùå –ù–µ –≤—Å–µ —É–∑–ª—ã –≥–æ—Ç–æ–≤—ã ($ready_nodes/$total_nodes)"
        failed_checks=$((failed_checks + 1))
    fi
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ critical applications
    local critical_apps=("argocd" "monitoring" "ingress-nginx")
    
    for app in "${critical_apps[@]}"; do
        local app_ready=$(kubectl get deployments -n $app --no-headers 2>/dev/null | \
            awk '{if($2==$4 && $4>0) print "ready"; else print "not-ready"}' | \
            grep -c "ready")
        
        if [ $app_ready -gt 0 ]; then
            log "‚úÖ Critical app $app –≥–æ—Ç–æ–≤–æ"
            health_checks=$((health_checks + 1))
        else
            log "‚ùå Critical app $app –Ω–µ –≥–æ—Ç–æ–≤–æ"
            failed_checks=$((failed_checks + 1))
        fi
    done
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ storage –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏
    if kubectl get pv &>/dev/null; then
        log "‚úÖ Storage –¥–æ—Å—Ç—É–ø–µ–Ω"
        health_checks=$((health_checks + 1))
    else
        log "‚ùå Storage –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω"
        failed_checks=$((failed_checks + 1))
    fi
    
    log "üìä Health check —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã: $health_checks —É—Å–ø–µ—à–Ω—ã—Ö, $failed_checks –Ω–µ—É—Å–ø–µ—à–Ω—ã—Ö"
    
    # –¢—Ä–∏–≥–≥–µ—Ä failover –µ—Å–ª–∏ –ø—Ä–µ–≤—ã—à–µ–Ω threshold
    if [ $failed_checks -ge $failover_threshold ]; then
        log "üö® –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï: –ü—Ä–µ–≤—ã—à–µ–Ω failover threshold ($failed_checks >= $failover_threshold)"
        trigger_cross_cloud_failover "primary_cloud_failure" "Failed health checks: $failed_checks"
    fi
    
    return $failed_checks
}

# –§—É–Ω–∫—Ü–∏—è cross-cloud failover
trigger_cross_cloud_failover() {
    local failure_reason=$1
    local details=$2
    
    log "üö® –¢–†–ò–ì–ì–ï–† CROSS-CLOUD FAILOVER"
    log "–ü—Ä–∏—á–∏–Ω–∞: $failure_reason"
    log "–î–µ—Ç–∞–ª–∏: $details"
    
    # –í—ã–±–æ—Ä target cloud –¥–ª—è failover
    local target_cloud="aws"  # Default to AWS secondary
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ AWS
    if ! curl -s -o /dev/null -w "%{http_code}" https://ec2.amazonaws.com/ | grep -q "200\|403"; then
        log "‚ö†Ô∏è AWS –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ Azure"
        target_cloud="azure"
    fi
    
    log "üéØ Target cloud –¥–ª—è failover: $target_cloud"
    
    # –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ failover –ø—Ä–æ—Ü–µ–¥—É—Ä—ã
    execute_failover_to_cloud "$target_cloud" "$failure_reason"
    
    # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ failover
    send_failover_notification "$target_cloud" "$failure_reason" "$details"
    
    # –°–æ–∑–¥–∞–Ω–∏–µ incident report
    create_failover_incident_report "$target_cloud" "$failure_reason" "$details"
}

# –§—É–Ω–∫—Ü–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è failover
execute_failover_to_cloud() {
    local target_cloud=$1
    local reason=$2
    
    log "üîÑ –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ failover –Ω–∞ $target_cloud"
    
    # –ü–æ–∏—Å–∫ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ backup –≤ target cloud
    local storage_location="${target_cloud}-secondary"
    if [ "$target_cloud" = "azure" ]; then
        storage_location="azure-tertiary"
    fi
    
    local latest_backup=$(velero backup get -l backup-type=cross-cloud-secondary -o json | \
        jq -r --arg location "$storage_location" \
        '.items[] | select(.spec.storageLocation == $location) | .metadata.name' | \
        sort | tail -1)
    
    if [ -n "$latest_backup" ] && [ "$latest_backup" != "null" ]; then
        log "üì¶ –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–∑ backup: $latest_backup"
        
        # –°–æ–∑–¥–∞–Ω–∏–µ restore
        velero restore create failover-restore-$(date +%s) \
            --from-backup $latest_backup \
            --wait --timeout 60m
        
        if [ $? -eq 0 ]; then
            log "‚úÖ Failover restore –∑–∞–≤–µ—Ä—à–µ–Ω —É—Å–ø–µ—à–Ω–æ"
            
            # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ DNS –¥–ª—è –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è —Ç—Ä–∞—Ñ–∏–∫–∞
            update_dns_for_failover "$target_cloud"
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ application readiness –ø–æ—Å–ª–µ failover
            verify_failover_success "$target_cloud"
        else
            log "‚ùå –û—à–∏–±–∫–∞ failover restore"
            return 1
        fi
    else
        log "‚ùå Backup –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ $target_cloud –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è"
        return 1
    fi
}

# –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è DNS –¥–ª—è failover
update_dns_for_failover() {
    local target_cloud=$1
    
    log "üåê –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ DNS –¥–ª—è failover –Ω–∞ $target_cloud"
    
    # –ü–æ–ª—É—á–µ–Ω–∏–µ IP load balancer –≤ target cloud
    local lb_ip=""
    
    case $target_cloud in
        "aws")
            # –î–ª—è AWS –ø–æ–ª—É—á–∞–µ–º ELB hostname –∏ —Ä–µ–∑–æ–ª–≤–∏–º –≤ IP
            lb_ip=$(dig +short hashfoundry-aws-lb.eu-central-1.elb.amazonaws.com | head -1)
            ;;
        "azure")
            # –î–ª—è Azure –ø–æ–ª—É—á–∞–µ–º public IP
            lb_ip="20.105.123.45"  # Example Azure public IP
            ;;
        *)
            log "‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π target cloud: $target_cloud"
            return 1
            ;;
    esac
    
    if [ -n "$lb_ip" ]; then
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ DNS –∑–∞–ø–∏—Å–µ–π —á–µ—Ä–µ–∑ Cloudflare API
        if [ -n "$CLOUDFLARE_API_TOKEN" ] && [ -n "$CLOUDFLARE_ZONE_ID" ]; then
            curl -X PUT "https://api.cloudflare.com/client/v4/zones/$CLOUDFLARE_ZONE_ID/dns_records/$DNS_RECORD_ID" \
                -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
                -H "Content-Type: application/json" \
                --data "{
                    \"type\": \"A\",
                    \"name\": \"app.hashfoundry.com\",
                    \"content\": \"$lb_ip\",
                    \"ttl\": 300,
                    \"comment\": \"Failover to $target_cloud at $(date)\"
                }"
            
            log "‚úÖ DNS –æ–±–Ω–æ–≤–ª–µ–Ω: app.hashfoundry.com -> $lb_ip ($target_cloud)"
        else
            log "‚ö†Ô∏è Cloudflare credentials –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã, DNS –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–ø—É—â–µ–Ω–æ"
        fi
    else
        log "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å IP –¥–ª—è $target_cloud"
        return 1
    fi
}

# –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —É—Å–ø–µ—à–Ω–æ—Å—Ç–∏ failover
verify_failover_success() {
    local target_cloud=$1
    
    log "üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ø–µ—à–Ω–æ—Å—Ç–∏ failover –Ω–∞ $target_cloud"
    
    local verification_passed=0
    local verification_failed=0
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π
    local critical_apps=("argocd" "monitoring" "ingress-nginx")
    
    for app in "${critical_apps[@]}"; do
        local app_ready=$(kubectl get deployments -n $app --no-headers 2>/dev/null | \
            awk '{if($2==$4 && $4>0) print "ready"; else print "not-ready"}' | \
            grep -c "ready")
        
        if [ $app_ready -gt 0 ]; then
            log "‚úÖ Failover verification: $app –≥–æ—Ç–æ–≤–æ"
            verification_passed=$((verification_passed + 1))
        else
            log "‚ùå Failover verification: $app –Ω–µ –≥–æ—Ç–æ–≤–æ"
            verification_failed=$((verification_failed + 1))
        fi
    done
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ external connectivity
    if curl -f -s "https://app.hashfoundry.com/health" &>/dev/null; then
        log "‚úÖ Failover verification: External connectivity —Ä–∞–±–æ—Ç–∞–µ—Ç"
        verification_passed=$((verification_passed + 1))
    else
        log "‚ùå Failover verification: External connectivity –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç"
        verification_failed=$((verification_failed + 1))
    fi
    
    log "üìä Failover verification: $verification_passed —É—Å–ø–µ—à–Ω—ã—Ö, $verification_failed –Ω–µ—É—Å–ø–µ—à–Ω—ã—Ö"
    
    if [ $verification_failed -eq 0 ]; then
        log "üéâ Failover –Ω–∞ $target_cloud –∑–∞–≤–µ—Ä—à–µ–Ω —É—Å–ø–µ—à–Ω–æ!"
        return 0
    else
        log "‚ö†Ô∏è Failover –Ω–∞ $target_cloud –∑–∞–≤–µ—Ä—à–µ–Ω —Å –ø—Ä–æ–±–ª–µ–º–∞–º–∏"
        return 1
    fi
}

# –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è replication report
create_replication_report() {
    local successful_replications=$1
    local failed_replications=$2
    
    local replication_report="/tmp/cross-cloud-replication-report-$TIMESTAMP.json"
    
    cat > $replication_report << REPLICATION_REPORT_EOF
{
  "report_timestamp": "$(date -Iseconds)",
  "cluster": "$(kubectl config current-context)",
  "replication_summary": {
    "successful_replications": $successful_replications,
    "failed_replications": $failed_replications,
    "success_rate": $(echo "scale=2; $successful_replications / ($successful_replications + $failed_replications) * 100" | bc -l 2>/dev/null || echo "0"),
    "total_backup_locations": $(velero backup-location get -o json | jq '.items | length'),
    "available_locations": $(velero backup-location get -o json | jq '[.items[] | select(.status.phase == "Available")] | length')
  },
  "cloud_distribution": {
$(velero backup get -o json | jq -r '
    group_by(.spec.storageLocation) | 
    map({
      location: .[0].spec.storageLocation,
      count: length,
      latest_backup: ([.[].metadata.creationTimestamp] | max)
    })[] | 
    "    \"\(.location)\": {\"count\": \(.count), \"latest\": \"\(.latest_backup)\"}"
' | paste -sd, -)
  }
}
REPLICATION_REPORT_EOF
    
    log "üìÑ Replication report —Å–æ–∑–¥–∞–Ω: $replication_report"
}

# –§—É–Ω–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ failover notification
send_failover_notification() {
    local target_cloud=$1
    local reason=$2
    local details=$3
    
    log "üìß –û—Ç–ø—Ä–∞–≤–∫–∞ failover notification"
    
    # –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ Slack
    if [ -n "$SLACK_WEBHOOK_URL" ]; then
        curl -X POST -H 'Content-type: application/json' \
            --data "{
                \"text\":\"üö® CROSS-CLOUD FAILOVER ACTIVATED\",
                \"attachments\":[{
                    \"color\":\"danger\",
                    \"fields\":[{
                        \"title\":\"Target Cloud\",
                        \"value\":\"$target_cloud\",
                        \"short\":true
                    },{
                        \"title\":\"Reason\",
                        \"value\":\"$reason\",
                        \"short\":true
                    },{
                        \"title\":\"Details\",
                        \"value\":\"$details\",
                        \"short\":false
                    },{
                        \"title\":\"Status\",
                        \"value\":\"Failover in progress\",
                        \"short\":true
                    }]
                }]
            }" \
            "$SLACK_WEBHOOK_URL"
    fi
    
    # –°–æ–∑–¥–∞–Ω–∏–µ PagerDuty incident
    if [ -n "$PAGERDUTY_INTEGRATION_KEY" ]; then
        curl -X POST "https://events.pagerduty.com/v2/enqueue" \
            -H "Content-Type: application/json" \
            --data "{
                \"routing_key\": \"$PAGERDUTY_INTEGRATION_KEY\",
                \"event_action\": \"trigger\",
                \"payload\": {
                    \"summary\": \"Cross-cloud failover to $target_cloud: $reason\",
                    \"severity\": \"critical\",
                    \"source\": \"cross-cloud-dr-system\",
                    \"custom_details\": {
                        \"target_cloud\": \"$target_cloud\",
                        \"reason\": \"$reason\",
                        \"details\": \"$details\"
                    }
                }
            }"
    fi
}

# –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è failover incident report
create_failover_incident_report() {
    local target_cloud=$1
    local reason=$2
    local details=$3
    
    local incident_report="/tmp/cross-cloud-failover-incident-$TIMESTAMP.json"
    
    cat > $incident_report << INCIDENT_REPORT_EOF
{
  "incident_timestamp": "$(date -Iseconds)",
  "incident_id": "CCDR-$(date +%Y%m%d-%H%M%S)",
  "failover_details": {
    "source_cloud": "$PRIMARY_CLOUD",
    "target_cloud": "$target_cloud",
    "failure_reason": "$reason",
    "failure_details": "$details",
    "detection_method": "automated_health_monitoring"
  },
  "infrastructure_status": {
    "primary_cluster_health": $(kubectl cluster-info &>/dev/null && echo "false" || echo "true"),
    "backup_locations_available": $(velero backup-location get -o json | jq '[.items[] | select(.status.phase == "Available")] | length'),
    "latest_backup_age_hours": $(velero backup get -o json | jq -r '[.items[].metadata.creationTimestamp] | max | fromdateiso8601 | (now - .) / 3600 | floor')
  },
  "recovery_actions": [
    "Automated failover triggered",
    "Target cloud selected: $target_cloud",
    "Latest backup identified for restore",
    "DNS failover initiated",
    "Stakeholder notifications sent"
  ],
  "next_steps": [
    "Monitor application recovery",
    "Verify data consistency",
    "Update runbooks based on lessons learned",
    "Plan primary cloud recovery"
  ]
}
INCIDENT_REPORT_EOF
    
    log "üìÑ Failover incident report: $incident_report"
}

# –û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
main() {
    case "$1" in
        analyze)
            analyze_multi_cloud_readiness
            ;;
        setup)
            create_cross_cloud_backup_strategy
            ;;
        replicate)
            execute_cross_cloud_replication
            ;;
        monitor)
            monitor_primary_cloud_health
            ;;
        failover)
            trigger_cross_cloud_failover "$2" "$3"
            ;;
        full)
            log "üöÄ –ó–∞–ø—É—Å–∫ –ø–æ–ª–Ω–æ–≥–æ cross-cloud DR management"
            analyze_multi_cloud_readiness
            create_cross_cloud_backup_strategy
            execute_cross_cloud_replication
            monitor_primary_cloud_health
            log "üéâ Cross-cloud DR management –∑–∞–≤–µ—Ä—à–µ–Ω!"
            ;;
        *)
            echo "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: $0 {analyze|setup|replicate|monitor|failover <reason> <details>|full}"
            echo "  analyze   - –ê–Ω–∞–ª–∏–∑ multi-cloud readiness"
            echo "  setup     - –°–æ–∑–¥–∞–Ω–∏–µ cross-cloud backup strategy"
            echo "  replicate - –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ cross-cloud replication"
            echo "  monitor   - –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ primary cloud health"
            echo "  failover  - –¢—Ä–∏–≥–≥–µ—Ä cross-cloud failover"
            echo "  full      - –ü–æ–ª–Ω–æ–µ cross-cloud DR management"
            exit 1
            ;;
    esac
}

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
trap 'log "‚ùå –û—à–∏–±–∫–∞ –≤ cross-cloud DR manager"; exit 1' ERR

# –ó–∞–ø—É—Å–∫ –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏
main "$@"
EOF

chmod +x cross-cloud-dr-manager.sh
```

### **2. –°–æ–∑–¥–∞–Ω–∏–µ terraform multi-cloud infrastructure:**
```bash
# –°–æ–∑–¥–∞—Ç—å —Å–∫—Ä–∏–ø—Ç multi-cloud-terraform.sh
cat << 'EOF' > multi-cloud-terraform.sh
#!/bin/bash

echo "üèóÔ∏è Multi-Cloud Terraform Infrastructure Manager"
echo "=============================================="

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
TERRAFORM_DIR="/tmp/multi-cloud-terraform"
TIMESTAMP=$(date +%Y%m%d-%H%M%S)

# –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è multi-cloud terraform configuration
create_multi_cloud_terraform() {
    echo "üìù –°–æ–∑–¥–∞–Ω–∏–µ multi-cloud Terraform configuration"
    
    mkdir -p $TERRAFORM_DIR
    
    # Main terraform configuration
    cat > $TERRAFORM_DIR/main.tf << TERRAFORM_MAIN_EOF
# Multi-Cloud Disaster Recovery Infrastructure
terraform {
  required_version = ">= 1.0"
  required_providers {
    digitalocean = {
      source  = "digitalocean/digitalocean"
      version = "~> 2.0"
    }
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.0"
    }
  }
}

# DigitalOcean Provider (Primary)
provider "digitalocean" {
  alias = "primary"
}

# AWS Provider (Secondary)
provider "aws" {
  alias  = "secondary"
  region = "eu-central-1"
}

# Azure Provider (Tertiary)
provider "azurerm" {
  alias = "tertiary"
  features {}
}

# DigitalOcean Kubernetes Cluster (Primary)
resource "digitalocean_kubernetes_cluster" "primary" {
  provider = digitalocean.primary
  
  name    = "hashfoundry-primary"
  region  = "fra1"
  version = "1.31.1-do.0"
  
  node_pool {
    name       = "primary-nodes"
    size       = "s-2vcpu-4gb"
    node_count = 3
    auto_scale = true
    min_nodes  = 3
    max_nodes  = 6
    
    labels = {
      environment = "production"
      role        = "primary"
      dr          = "enabled"
    }
  }
  
  tags = ["production", "primary", "dr-enabled"]
}

# AWS EKS Cluster (Secondary)
module "aws_eks_secondary" {
  source = "./modules/aws-eks"
  providers = {
    aws = aws.secondary
  }
  
  cluster_name    = "hashfoundry-secondary"
  cluster_version = "1.31"
  
  vpc_cidr = "10.1.0.0/16"
  
  node_groups = {
    secondary = {
      instance_types = ["m5.large"]
      min_size      = 3
      max_size      = 6
      desired_size  = 3
      
      labels = {
        environment = "disaster-recovery"
        role        = "secondary"
        dr          = "enabled"
      }
    }
  }
  
  tags = {
    Environment = "disaster-recovery"
    Role        = "secondary"
    DR          = "enabled"
  }
}

# Azure AKS Cluster (Tertiary)
module "azure_aks_tertiary" {
  source = "./modules/azure-aks"
  providers = {
    azurerm = azurerm.tertiary
  }
  
  cluster_name       = "hashfoundry-tertiary"
  location           = "West Europe"
  kubernetes_version = "1.31"
  
  resource_group_name = "hashfoundry-dr-rg"
  
  default_node_pool = {
    name       = "tertiary"
    vm_size    = "Standard_D2s_v3"
    node_count = 3
    min_count  = 3
    max_count  = 6
    
    node_labels = {
      environment = "disaster-recovery"
      role        = "tertiary"
      dr          = "enabled"
    }
  }
  
  tags = {
    Environment = "disaster-recovery"
    Role        = "tertiary"
    DR          = "enabled"
  }
}

# Cross-Cloud Storage for Backup
resource "digitalocean_spaces_bucket" "primary_backup" {
  provider = digitalocean.primary
  
  name   = "hashfoundry-backup-primary"
  region = "fra1"
  
  versioning {
    enabled = true
  }
  
  lifecycle_rule {
    id      = "backup_lifecycle"
    enabled = true
    
    transition {
      days          = 30
      storage_class = "IA"
    }
    
    expiration {
      days = 2555  # 7 years
    }
  }
}

resource "aws_s3_bucket" "secondary_backup" {
  provider = aws.secondary
  
  bucket = "hashfoundry-backup-secondary"
  
  tags = {
    Purpose = "cross-cloud-dr"
    Tier    = "secondary"
  }
}

resource "aws_s3_bucket_versioning" "secondary_backup" {
  provider = aws.secondary
  bucket   = aws_s3_bucket.secondary_backup.id
  
  versioning_configuration {
    status = "Enabled"
  }
}

resource "aws_s3_bucket_lifecycle_configuration" "secondary_backup" {
  provider = aws.secondary
  bucket   = aws_s3_bucket.secondary_backup.id
  
  rule {
    id     = "backup_lifecycle"
    status = "Enabled"
    
    transition {
      days          = 30
      storage_class = "STANDARD_IA"
    }
    
    transition {
      days          = 90
      storage_class = "GLACIER"
    }
    
    expiration {
      days = 2555  # 7 years
    }
  }
}

resource "azurerm_resource_group" "tertiary_dr" {
  provider = azurerm.tertiary
  
  name     = "hashfoundry-dr-rg"
  location = "West Europe"
  
  tags = {
    Purpose = "cross-cloud-dr"
    Tier    = "tertiary"
  }
}

resource "azurerm_storage_account" "tertiary_backup" {
  provider = azurerm.tertiary
  
  name                     = "hashfoundrydrbackup"
  resource_group_name      = azurerm_resource_group.tertiary_dr.name
  location                 = azurerm_resource_group.tertiary_dr.location
  account_tier             = "Standard"
  account_replication_type = "GRS"
  
  blob_properties {
    versioning_enabled = true
    
    delete_retention_policy {
      days = 2555  # 7 years
    }
  }
  
  tags = {
    Purpose = "cross-cloud-dr"
    Tier    = "tertiary"
  }
}

# Cross-Cloud VPN Connections
resource "aws_vpn_gateway" "secondary_vpn" {
  provider = aws.secondary
  vpc_id   = module.aws_eks_secondary.vpc_id
  
  tags = {
    Name = "hashfoundry-secondary-vpn"
  }
}

resource "azurerm_virtual_network_gateway" "tertiary_vpn" {
  provider = azurerm.tertiary
  
  name                = "hashfoundry-tertiary-vpn"
  location            = azurerm_resource_group.tertiary_dr.location
  resource_group_name = azurerm_resource_group.tertiary_dr.name
  
  type     = "Vpn"
  vpn_type = "RouteBased"
  
  active_active = false
  enable_bgp    = false
  sku           = "VpnGw1"
  
  ip_configuration {
    name                          = "vnetGatewayConfig"
    public_ip_address_id          = azurerm_public_ip.tertiary_vpn.id
    private_ip_address_allocation = "Dynamic"
    subnet_id                     = azurerm_subnet.tertiary_gateway.id
  }
}

resource "azurerm_public_ip" "tertiary_vpn" {
  provider = azurerm.tertiary
  
  name                = "hashfoundry-tertiary-vpn-ip"
  location            = azurerm_resource_group.tertiary_dr.location
  resource_group_name = azurerm_resource_group.tertiary_dr.name
  allocation_method   = "Dynamic"
}

resource "azurerm_subnet" "tertiary_gateway" {
  provider = azurerm.tertiary
  
  name                 = "GatewaySubnet"
  resource_group_name  = azurerm_resource_group.tertiary_dr.name
  virtual_network_name = module.azure_aks_tertiary.vnet_name
  address_prefixes     = ["10.2.1.0/27"]
}
TERRAFORM_MAIN_EOF
    
    # Variables file
    cat > $TERRAFORM_DIR/variables.tf << TERRAFORM_VARS_EOF
variable "digitalocean_token" {
  description = "DigitalOcean API Token"
  type        = string
  sensitive   = true
}

variable "aws_access_key" {
  description = "AWS Access Key"
  type        = string
  sensitive   = true
}

variable "aws_secret_key" {
  description = "AWS Secret Key"
  type        = string
  sensitive   = true
}

variable "azure_subscription_id" {
  description = "Azure Subscription ID"
  type        = string
  sensitive   = true
}

variable "azure_client_id" {
  description = "Azure Client ID"
  type        = string
  sensitive   = true
}

variable "azure_client_secret" {
  description = "Azure Client Secret"
  type        = string
  sensitive   = true
}

variable "azure_tenant_id" {
  description = "Azure Tenant ID"
  type        = string
  sensitive   = true
}

variable "environment" {
  description = "Environment name"
  type        = string
  default     = "production"
}

variable "project_name" {
  description = "Project name"
  type        = string
  default     = "hashfoundry"
}
TERRAFORM_VARS_EOF
    
    # Outputs file
    cat > $TERRAFORM_DIR/outputs.tf << TERRAFORM_OUTPUTS_EOF
output "primary_cluster_endpoint" {
  description = "DigitalOcean Kubernetes cluster endpoint"
  value       = digitalocean_kubernetes_cluster.primary.endpoint
  sensitive   = true
}

output "primary_cluster_token" {
  description = "DigitalOcean Kubernetes cluster token"
  value       = digitalocean_kubernetes_cluster.primary.kube_config[0].token
  sensitive   = true
}

output "secondary_cluster_endpoint" {
  description = "AWS EKS cluster endpoint"
  value       = module.aws_eks_secondary.cluster_endpoint
  sensitive   = true
}

output "tertiary_cluster_endpoint" {
  description = "Azure AKS cluster endpoint"
  value       = module.azure_aks_tertiary.cluster_endpoint
  sensitive   = true
}

output "backup_storage_locations" {
  description = "Cross-cloud backup storage locations"
  value = {
    primary   = digitalocean_spaces_bucket.primary_backup.name
    secondary = aws_s3_bucket.secondary_backup.bucket
    tertiary  = azurerm_storage_account.tertiary_backup.name
  }
}

output "vpn_gateways" {
  description = "Cross-cloud VPN gateway information"
  value = {
    aws_vpn_gateway_id   = aws_vpn_gateway.secondary_vpn.id
    azure_vpn_gateway_id = azurerm_virtual_network_gateway.tertiary_vpn.id
  }
}
TERRAFORM_OUTPUTS_EOF
    
    echo "‚úÖ Multi-cloud Terraform configuration —Å–æ–∑–¥–∞–Ω–∞ –≤ $TERRAFORM_DIR"
}

# –§—É–Ω–∫—Ü–∏—è —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏—è multi-cloud infrastructure
deploy_multi_cloud_infrastructure() {
    echo "üöÄ –†–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ multi-cloud infrastructure"
    
    cd $TERRAFORM_DIR
    
    # Terraform init
    terraform init
    
    # Terraform plan
    terraform plan -out=multi-cloud.tfplan
    
    # Terraform apply
    terraform apply multi-cloud.tfplan
    
    if [ $? -eq 0 ]; then
        echo "‚úÖ Multi-cloud infrastructure —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç–∞ —É—Å–ø–µ—à–Ω–æ"
        
        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ outputs
        terraform output -json > multi-cloud-outputs.json
        
        echo "üìÑ Terraform outputs —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ multi-cloud-outputs.json"
    else
        echo "‚ùå –û—à–∏–±–∫–∞ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏—è multi-cloud infrastructure"
        return 1
    fi
}

# –û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞
case "$1" in
    create)
        create_multi_cloud_terraform
        ;;
    deploy)
        deploy_multi_cloud_infrastructure
        ;;
    full)
        create_multi_cloud_terraform
        deploy_multi_cloud_infrastructure
        ;;
    *)
        echo "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: $0 {create|deploy|full}"
        echo "  create - –°–æ–∑–¥–∞–Ω–∏–µ Terraform configuration"
        echo "  deploy - –†–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ infrastructure"
        echo "  full   - –°–æ–∑–¥–∞–Ω–∏–µ –∏ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ"
        exit 1
        ;;
esac
EOF

chmod +x multi-cloud-terraform.sh
```

## üìä **–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ cross-cloud disaster recovery:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              Cross-Cloud Disaster Recovery                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Multi-Cloud Infrastructure                                ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ Primary     ‚îÇ Secondary   ‚îÇ Tertiary    ‚îÇ Connectivity‚îÇ  ‚îÇ
‚îÇ  ‚îÇ DigitalOcean‚îÇ AWS         ‚îÇ Azure       ‚îÇ & Routing   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ fra1    ‚îÇ ‚îú‚îÄ‚îÄ eu-c-1  ‚îÇ ‚îú‚îÄ‚îÄ west-eu ‚îÇ ‚îú‚îÄ‚îÄ VPN     ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ K8s 1.31‚îÇ ‚îú‚îÄ‚îÄ EKS     ‚îÇ ‚îú‚îÄ‚îÄ AKS     ‚îÇ ‚îú‚îÄ‚îÄ DNS     ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ 3-6 nodes‚îÇ ‚îú‚îÄ‚îÄ 3-6 nodes‚îÇ ‚îú‚îÄ‚îÄ 3-6 nodes‚îÇ ‚îú‚îÄ‚îÄ LB      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ ‚îî‚îÄ‚îÄ Spaces  ‚îÇ ‚îî‚îÄ‚îÄ S3      ‚îÇ ‚îî‚îÄ‚îÄ Blob    ‚îÇ ‚îî‚îÄ‚îÄ Failover‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Data Replication & Backup Strategy                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ Real-time Application Data Sync                    ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ Scheduled Cross-Cloud Backup Replication           ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ Configuration & Secret Synchronization             ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ Infrastructure State Management                    ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚îî‚îÄ‚îÄ Automated Failover & Recovery Procedures           ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üéØ **Best Practices –¥–ª—è cross-cloud DR:**

### **1. Infrastructure Design**
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ Infrastructure as Code –¥–ª—è consistency
- –ù–∞—Å—Ç—Ä–æ–π—Ç–µ automated health monitoring
- –û–±–µ—Å–ø–µ—á—å—Ç–µ network connectivity –º–µ–∂–¥—É clouds
- –ü–ª–∞–Ω–∏—Ä—É–π—Ç–µ capacity –¥–ª—è failover scenarios

### **2. Data Management**
- –†–µ–ø–ª–∏—Ü–∏—Ä—É–π—Ç–µ –¥–∞–Ω–Ω—ã–µ –≤ real-time –≥–¥–µ –≤–æ–∑–º–æ–∂–Ω–æ
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ tiered backup strategy
- –û–±–µ—Å–ø–µ—á—å—Ç–µ data consistency checks
- –ü–ª–∞–Ω–∏—Ä—É–π—Ç–µ data migration procedures

### **3. Automation & Orchestration**
- –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∏—Ä—É–π—Ç–µ failover detection
- –ù–∞—Å—Ç—Ä–æ–π—Ç–µ automated recovery procedures
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ GitOps –¥–ª—è configuration management
- –û–±–µ—Å–ø–µ—á—å—Ç–µ automated testing DR procedures

### **4. Monitoring & Alerting**
- –ú–æ–Ω–∏—Ç–æ—Ä—å—Ç–µ health –≤—Å–µ—Ö clouds
- –ù–∞—Å—Ç—Ä–æ–π—Ç–µ cross-cloud connectivity alerts
- –û—Ç—Å–ª–µ–∂–∏–≤–∞–π—Ç–µ replication lag
- –û–±–µ—Å–ø–µ—á—å—Ç–µ comprehensive logging

**Cross-cloud disaster recovery –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –∑–∞—â–∏—Ç—É –æ—Ç –∫–∞—Ç–∞—Å—Ç—Ä–æ—Ñ–∏—á–µ—Å–∫–∏—Ö —Å–±–æ–µ–≤ –∏ —è–≤–ª—è–µ—Ç—Å—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω—ã–º –¥–ª—è enterprise-—É—Ä–æ–≤–Ω—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏!**
