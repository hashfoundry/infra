# 168. –ö–∞–∫ —É–ø—Ä–∞–≤–ª—è—Ç—å –∂–∏–∑–Ω–µ–Ω–Ω—ã–º —Ü–∏–∫–ª–æ–º –∏ —Ö—Ä–∞–Ω–µ–Ω–∏–µ–º —Ä–µ–∑–µ—Ä–≤–Ω—ã—Ö –∫–æ–ø–∏–π?

## üéØ **–ß—Ç–æ —Ç–∞–∫–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∂–∏–∑–Ω–µ–Ω–Ω—ã–º —Ü–∏–∫–ª–æ–º backup?**

**–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∂–∏–∑–Ω–µ–Ω–Ω—ã–º —Ü–∏–∫–ª–æ–º backup** ‚Äî —ç—Ç–æ –∫–æ–º–ø–ª–µ–∫—Å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏ —Å–æ–∑–¥–∞–Ω–∏—è, –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏, —Ö—Ä–∞–Ω–µ–Ω–∏—è, –∞—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω–∏—è –∏ —É–¥–∞–ª–µ–Ω–∏—è —Ä–µ–∑–µ—Ä–≤–Ω—ã—Ö –∫–æ–ø–∏–π –≤ Kubernetes. –í–∫–ª—é—á–∞–µ—Ç retention policies, storage tiering, cost optimization, compliance management, automated lifecycle transitions –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –≤—Å–µ—Ö —ç—Ç–∞–ø–æ–≤ –æ—Ç —Å–æ–∑–¥–∞–Ω–∏—è –¥–æ –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è backup –¥–∞–Ω–Ω—ã—Ö.

## üèóÔ∏è **–û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã lifecycle management:**

### **1. Lifecycle Stages**
- **Creation**: –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ backup –ø–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—é –∏ —Å–æ–±—ã—Ç–∏—è–º
- **Active Retention**: –ë—ã—Å—Ç—Ä—ã–π –¥–æ—Å—Ç—É–ø –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è (hot storage)
- **Warm Storage**: –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–ª—è —Ä–µ–≥—É–ª—è—Ä–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
- **Cold Archival**: –î–æ–ª–≥–æ—Å—Ä–æ—á–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å –º–µ–¥–ª–µ–Ω–Ω—ã–º –¥–æ—Å—Ç—É–ø–æ–º
- **Secure Deletion**: –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ —Å audit trail

### **2. Storage Tiering Strategy**
- **Hot Tier**: SSD storage –¥–ª—è –Ω–µ–¥–∞–≤–Ω–∏—Ö backup (< 7 –¥–Ω–µ–π)
- **Warm Tier**: Standard storage –¥–ª—è —Ä–µ–≥—É–ª—è—Ä–Ω—ã—Ö backup (7-30 –¥–Ω–µ–π)
- **Cold Tier**: Infrequent access storage (30 –¥–Ω–µ–π - 1 –≥–æ–¥)
- **Glacier Tier**: Archive storage –¥–ª—è compliance (> 1 –≥–æ–¥–∞)

### **3. Cost Optimization Components**
- **Automated Tiering**: –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –º–µ–∂–¥—É storage –∫–ª–∞—Å—Å–∞–º–∏
- **Compression & Deduplication**: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ä–∞–∑–º–µ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö
- **Budget Monitoring**: –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –∑–∞—Ç—Ä–∞—Ç –Ω–∞ storage
- **Policy Enforcement**: –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ retention rules

## üìä **–ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–µ—Ä—ã –∏–∑ –≤–∞—à–µ–≥–æ HA –∫–ª–∞—Å—Ç–µ—Ä–∞:**

### **1. –ê–Ω–∞–ª–∏–∑ —Ç–µ–∫—É—â–µ–≥–æ lifecycle backup:**
```bash
# –ê–Ω–∞–ª–∏–∑ –≤—Å–µ—Ö backup –∏ –∏—Ö –≤–æ–∑—Ä–∞—Å—Ç–∞
kubectl get backups -n velero --sort-by=.metadata.creationTimestamp -o custom-columns=NAME:.metadata.name,AGE:.metadata.creationTimestamp,SIZE:.status.progress.totalItems,TIER:.metadata.labels.backup-tier

# –ü—Ä–æ–≤–µ—Ä–∫–∞ storage usage –ø–æ tiers
velero backup get -o json | jq -r '.items[] | "\(.metadata.labels["backup-tier"] // "unknown"):\(.metadata.name):\(.status.progress.totalItems // 0) items"' | sort

# –ê–Ω–∞–ª–∏–∑ retention policies
velero schedule get -o custom-columns=NAME:.metadata.name,SCHEDULE:.spec.schedule,TTL:.spec.template.ttl,TIER:.spec.template.metadata.labels.backup-tier

# –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ storage costs
kubectl get pv -l backup-storage=true -o custom-columns=NAME:.metadata.name,SIZE:.spec.capacity.storage,STORAGECLASS:.spec.storageClassName,STATUS:.status.phase
```

### **2. –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ lifecycle –ø—Ä–æ–±–ª–µ–º:**
```bash
# –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞—Ä—É—à–µ–Ω–∏–π retention policies
velero backup get -o json | jq -r '.items[] | select((.metadata.creationTimestamp | fromdateiso8601) < (now - 2592000)) | "\(.metadata.name): \((now - (.metadata.creationTimestamp | fromdateiso8601))/86400 | floor) days old"'

# –ê–Ω–∞–ª–∏–∑ failed lifecycle transitions
kubectl get events --all-namespaces --field-selector reason=BackupTieringFailed -o custom-columns=NAMESPACE:.namespace,OBJECT:.involvedObject.name,MESSAGE:.message,TIME:.firstTimestamp

# –ü—Ä–æ–≤–µ—Ä–∫–∞ storage usage alerts
kubectl get prometheusrules -n monitoring -o json | jq -r '.items[] | select(.spec.groups[].rules[]?.alert | test("BackupStorage.*")) | .metadata.name'
```

### **3. –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ lifecycle –º–µ—Ç—Ä–∏–∫:**
```bash
# –ü—Ä–æ–≤–µ—Ä–∫–∞ backup distribution –ø–æ tiers
kubectl get backups -n velero -o json | jq -r 'group_by(.metadata.labels["backup-tier"]) | map({tier: .[0].metadata.labels["backup-tier"], count: length}) | .[]'

# –ê–Ω–∞–ª–∏–∑ storage costs
aws s3api list-buckets --query 'Buckets[?contains(Name, `backup`)].Name' --output table 2>/dev/null || echo "AWS CLI not configured"
```

## üîÑ **–î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è comprehensive lifecycle management:**

### **1. –°–æ–∑–¥–∞–Ω–∏–µ automated backup lifecycle framework:**
```bash
# –°–æ–∑–¥–∞—Ç—å —Å–∫—Ä–∏–ø—Ç backup-lifecycle-manager.sh
cat << 'EOF' > backup-lifecycle-manager.sh
#!/bin/bash

echo "üìÖ Comprehensive Backup Lifecycle Manager"
echo "========================================"

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
VELERO_NAMESPACE="velero"
MONITORING_NAMESPACE="monitoring"
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
LOG_FILE="/var/log/backup-lifecycle-$TIMESTAMP.log"

# Storage tier configurations
declare -A TIER_CONFIG=(
    ["hot"]="7:fast-ssd:0.25"
    ["warm"]="30:standard:0.10"
    ["cold"]="365:cold:0.04"
    ["glacier"]="2555:glacier:0.01"  # 7 years
)

# –§—É–Ω–∫—Ü–∏—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a $LOG_FILE
}

# –§—É–Ω–∫—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞ backup ecosystem
analyze_backup_ecosystem() {
    log "üîç –ê–Ω–∞–ª–∏–∑ backup ecosystem"
    
    local analysis_file="/tmp/backup-ecosystem-analysis-$TIMESTAMP.json"
    
    # –°–±–æ—Ä comprehensive –¥–∞–Ω–Ω—ã—Ö
    cat > $analysis_file << ANALYSIS_EOF
{
  "analysis_timestamp": "$(date -Iseconds)",
  "cluster_context": "$(kubectl config current-context)",
  "backup_ecosystem": {
    "total_backups": $(velero backup get -o json | jq '.items | length'),
    "backup_distribution": {
$(velero backup get -o json | jq -r '
    group_by(.metadata.labels["backup-tier"] // "unclassified") | 
    map({
      tier: .[0].metadata.labels["backup-tier"] // "unclassified",
      count: length,
      total_size: [.[].status.progress.totalItems // 0] | add,
      oldest: [.[].metadata.creationTimestamp] | min,
      newest: [.[].metadata.creationTimestamp] | max
    })[] | 
    "      \"\(.tier)\": {\"count\": \(.count), \"total_items\": \(.total_size), \"oldest\": \"\(.oldest)\", \"newest\": \"\(.newest)\"}"
' | paste -sd, -)
    },
    "storage_locations": {
$(kubectl get backupstoragelocations -n $VELERO_NAMESPACE -o json | jq -r '
    .items[] | 
    {
      name: .metadata.name,
      provider: .spec.provider,
      bucket: .spec.objectStorage.bucket,
      available: .status.phase == "Available"
    } | 
    "      \"\(.name)\": {\"provider\": \"\(.provider)\", \"bucket\": \"\(.bucket)\", \"available\": \(.available)}"
' | paste -sd, -)
    },
    "schedules": {
$(kubectl get schedules -n $VELERO_NAMESPACE -o json | jq -r '
    .items[] | 
    {
      name: .metadata.name,
      schedule: .spec.schedule,
      ttl: .spec.template.ttl,
      last_backup: .status.lastBackup,
      phase: .status.phase
    } | 
    "      \"\(.name)\": {\"schedule\": \"\(.schedule)\", \"ttl\": \"\(.ttl)\", \"last_backup\": \"\(.last_backup)\", \"phase\": \"\(.phase)\"}"
' | paste -sd, -)
    }
  },
  "storage_analysis": {
    "pv_usage": {
$(kubectl get pv -o json | jq -r '
    .items[] | 
    select(.metadata.labels["backup-storage"] == "true") | 
    {
      name: .metadata.name,
      capacity: .spec.capacity.storage,
      storage_class: .spec.storageClassName,
      status: .status.phase,
      claim: .spec.claimRef.name
    } | 
    "      \"\(.name)\": {\"capacity\": \"\(.capacity)\", \"storage_class\": \"\(.storage_class)\", \"status\": \"\(.status)\"}"
' | paste -sd, -)
    }
  }
}
ANALYSIS_EOF
    
    log "üìÑ Ecosystem analysis —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ $analysis_file"
    
    # –ö—Ä–∞—Ç–∫–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    local total_backups=$(velero backup get -o json | jq '.items | length')
    local active_schedules=$(kubectl get schedules -n $VELERO_NAMESPACE -o json | jq '.items | length')
    local storage_locations=$(kubectl get backupstoragelocations -n $VELERO_NAMESPACE -o json | jq '.items | length')
    
    log "üìä Ecosystem —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:"
    log "  üì¶ –í—Å–µ–≥–æ backup: $total_backups"
    log "  ‚è∞ –ê–∫—Ç–∏–≤–Ω—ã—Ö schedules: $active_schedules"
    log "  üíæ Storage locations: $storage_locations"
    
    return 0
}

# –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è retention policies
create_retention_policies() {
    log "üìã –°–æ–∑–¥–∞–Ω–∏–µ comprehensive retention policies"
    
    # –°–æ–∑–¥–∞–Ω–∏–µ retention policy ConfigMap
    kubectl apply -f - << RETENTION_POLICIES_EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: backup-retention-policies
  namespace: $VELERO_NAMESPACE
  labels:
    component: backup-lifecycle
data:
  retention-config.yaml: |
    retention_policies:
      critical_production:
        daily:
          retention_days: 30
          storage_tier: "hot"
          storage_location: "primary-backup-location"
          cost_per_gb_month: 0.25
        weekly:
          retention_days: 84  # 12 weeks
          storage_tier: "warm"
          storage_location: "standard-backup-location"
          cost_per_gb_month: 0.10
        monthly:
          retention_days: 365  # 12 months
          storage_tier: "cold"
          storage_location: "cold-backup-location"
          cost_per_gb_month: 0.04
        yearly:
          retention_days: 2555  # 7 years
          storage_tier: "glacier"
          storage_location: "archive-backup-location"
          cost_per_gb_month: 0.01
      
      standard_production:
        daily:
          retention_days: 7
          storage_tier: "hot"
          storage_location: "primary-backup-location"
        weekly:
          retention_days: 28  # 4 weeks
          storage_tier: "warm"
          storage_location: "standard-backup-location"
        monthly:
          retention_days: 180  # 6 months
          storage_tier: "cold"
          storage_location: "cold-backup-location"
      
      development:
        daily:
          retention_days: 3
          storage_tier: "hot"
          storage_location: "dev-backup-location"
        weekly:
          retention_days: 14  # 2 weeks
          storage_tier: "warm"
          storage_location: "dev-backup-location"
      
      compliance_archive:
        yearly:
          retention_days: 2555  # 7 years minimum
          storage_tier: "glacier"
          storage_location: "compliance-backup-location"
          legal_hold_support: true
          encryption_required: true
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: backup-lifecycle-automation
  namespace: $VELERO_NAMESPACE
data:
  lifecycle-rules.yaml: |
    automation_rules:
      tier_transitions:
        hot_to_warm:
          trigger_age_days: 7
          source_tier: "hot"
          target_tier: "warm"
          conditions:
            - backup_tier != "critical"
        warm_to_cold:
          trigger_age_days: 30
          source_tier: "warm"
          target_tier: "cold"
          conditions:
            - backup_tier != "development"
        cold_to_glacier:
          trigger_age_days: 365
          source_tier: "cold"
          target_tier: "glacier"
          conditions:
            - backup_tier == "critical"
            - compliance_required == "true"
      
      deletion_rules:
        development_cleanup:
          trigger_age_days: 14
          backup_tier: "development"
          force_delete: true
        standard_cleanup:
          trigger_age_days: 180
          backup_tier: "standard"
          archive_before_delete: false
        critical_archive:
          trigger_age_days: 2555
          backup_tier: "critical"
          archive_before_delete: true
          require_approval: true
RETENTION_POLICIES_EOF
    
    log "‚úÖ Retention policies —Å–æ–∑–¥–∞–Ω—ã"
}

# –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è storage tiers
create_storage_tiers() {
    log "üíæ –°–æ–∑–¥–∞–Ω–∏–µ storage tiers"
    
    # Hot tier storage location
    kubectl apply -f - << HOT_TIER_EOF
apiVersion: velero.io/v1
kind: BackupStorageLocation
metadata:
  name: hot-tier-storage
  namespace: $VELERO_NAMESPACE
  labels:
    storage-tier: "hot"
    cost-tier: "high"
spec:
  provider: aws
  objectStorage:
    bucket: hashfoundry-backup-hot
    prefix: hot-tier
  config:
    region: fra1
    s3StorageClass: STANDARD
    serverSideEncryption: AES256
  accessMode: ReadWrite
HOT_TIER_EOF
    
    # Warm tier storage location
    kubectl apply -f - << WARM_TIER_EOF
apiVersion: velero.io/v1
kind: BackupStorageLocation
metadata:
  name: warm-tier-storage
  namespace: $VELERO_NAMESPACE
  labels:
    storage-tier: "warm"
    cost-tier: "medium"
spec:
  provider: aws
  objectStorage:
    bucket: hashfoundry-backup-warm
    prefix: warm-tier
  config:
    region: fra1
    s3StorageClass: STANDARD_IA
    serverSideEncryption: AES256
  accessMode: ReadWrite
WARM_TIER_EOF
    
    # Cold tier storage location
    kubectl apply -f - << COLD_TIER_EOF
apiVersion: velero.io/v1
kind: BackupStorageLocation
metadata:
  name: cold-tier-storage
  namespace: $VELERO_NAMESPACE
  labels:
    storage-tier: "cold"
    cost-tier: "low"
spec:
  provider: aws
  objectStorage:
    bucket: hashfoundry-backup-cold
    prefix: cold-tier
  config:
    region: fra1
    s3StorageClass: STANDARD_IA
    serverSideEncryption: AES256
  accessMode: ReadWrite
COLD_TIER_EOF
    
    # Glacier tier storage location
    kubectl apply -f - << GLACIER_TIER_EOF
apiVersion: velero.io/v1
kind: BackupStorageLocation
metadata:
  name: glacier-tier-storage
  namespace: $VELERO_NAMESPACE
  labels:
    storage-tier: "glacier"
    cost-tier: "minimal"
spec:
  provider: aws
  objectStorage:
    bucket: hashfoundry-backup-glacier
    prefix: glacier-tier
  config:
    region: fra1
    s3StorageClass: GLACIER
    serverSideEncryption: AES256
  accessMode: ReadWrite
GLACIER_TIER_EOF
    
    log "‚úÖ Storage tiers —Å–æ–∑–¥–∞–Ω—ã"
}

# –§—É–Ω–∫—Ü–∏—è automated tiering
execute_automated_tiering() {
    log "üîÑ –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ automated tiering"
    
    # –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö backup –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
    local all_backups=$(velero backup get -o json)
    
    # Hot to Warm tier transition
    echo "$all_backups" | jq -r --arg cutoff "$(date -d '7 days ago' -u +%Y-%m-%dT%H:%M:%SZ)" '
        .items[] | 
        select(.metadata.creationTimestamp < $cutoff) |
        select(.spec.storageLocation == "hot-tier-storage") |
        select(.metadata.labels["backup-tier"] != "critical") |
        .metadata.name
    ' | while read backup_name; do
        if [ -n "$backup_name" ]; then
            log "üîÑ –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ $backup_name: hot ‚Üí warm tier"
            transition_backup_tier "$backup_name" "hot" "warm"
        fi
    done
    
    # Warm to Cold tier transition
    echo "$all_backups" | jq -r --arg cutoff "$(date -d '30 days ago' -u +%Y-%m-%dT%H:%M:%SZ)" '
        .items[] | 
        select(.metadata.creationTimestamp < $cutoff) |
        select(.spec.storageLocation == "warm-tier-storage") |
        select(.metadata.labels["backup-tier"] != "development") |
        .metadata.name
    ' | while read backup_name; do
        if [ -n "$backup_name" ]; then
            log "üßä –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ $backup_name: warm ‚Üí cold tier"
            transition_backup_tier "$backup_name" "warm" "cold"
        fi
    done
    
    # Cold to Glacier tier transition
    echo "$all_backups" | jq -r --arg cutoff "$(date -d '365 days ago' -u +%Y-%m-%dT%H:%M:%SZ)" '
        .items[] | 
        select(.metadata.creationTimestamp < $cutoff) |
        select(.spec.storageLocation == "cold-tier-storage") |
        select(.metadata.labels["backup-tier"] == "critical") |
        .metadata.name
    ' | while read backup_name; do
        if [ -n "$backup_name" ]; then
            log "üèîÔ∏è –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ $backup_name: cold ‚Üí glacier tier"
            transition_backup_tier "$backup_name" "cold" "glacier"
        fi
    done
    
    log "‚úÖ Automated tiering –∑–∞–≤–µ—Ä—à–µ–Ω"
}

# –§—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –º–µ–∂–¥—É tiers
transition_backup_tier() {
    local backup_name=$1
    local source_tier=$2
    local target_tier=$3
    
    log "üì¶ Transition: $backup_name ($source_tier ‚Üí $target_tier)"
    
    # –°–æ–∑–¥–∞–Ω–∏–µ backup –≤ target tier
    local new_backup_name="${backup_name}-${target_tier}-$(date +%s)"
    
    velero backup create $new_backup_name \
        --from-backup $backup_name \
        --storage-location "${target_tier}-tier-storage" \
        --labels "backup-tier=${target_tier},original-backup=${backup_name},transition-date=$(date -u +%Y-%m-%d)" \
        --wait
    
    if [ $? -eq 0 ]; then
        log "‚úÖ Backup —Å–æ–∑–¥–∞–Ω –≤ $target_tier tier: $new_backup_name"
        
        # –£–¥–∞–ª–µ–Ω–∏–µ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ backup
        velero backup delete $backup_name --confirm
        
        log "üóëÔ∏è –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π backup —É–¥–∞–ª–µ–Ω: $backup_name"
        
        # –°–æ–∑–¥–∞–Ω–∏–µ audit –∑–∞–ø–∏—Å–∏
        create_tier_transition_audit "$backup_name" "$source_tier" "$target_tier" "$new_backup_name"
    else
        log "‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è backup –≤ $target_tier tier"
        return 1
    fi
}

# –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è audit –∑–∞–ø–∏—Å–∏
create_tier_transition_audit() {
    local original_backup=$1
    local source_tier=$2
    local target_tier=$3
    local new_backup=$4
    
    local audit_file="/var/log/backup-tier-transitions.audit"
    
    cat >> $audit_file << AUDIT_EOF
{
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "action": "tier_transition",
  "original_backup": "$original_backup",
  "source_tier": "$source_tier",
  "target_tier": "$target_tier",
  "new_backup": "$new_backup",
  "automated": true,
  "cluster": "$(kubectl config current-context)"
}
AUDIT_EOF
}

# –§—É–Ω–∫—Ü–∏—è cost analysis
perform_cost_analysis() {
    log "üí∞ –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ cost analysis"
    
    local cost_report="/tmp/backup-cost-analysis-$TIMESTAMP.json"
    
    # –ê–Ω–∞–ª–∏–∑ backup –ø–æ tiers
    local backup_stats=$(velero backup get -o json | jq -r '
        group_by(.spec.storageLocation) | 
        map({
            tier: (.[0].spec.storageLocation | split("-")[0]),
            count: length,
            total_items: [.[].status.progress.totalItems // 0] | add,
            avg_age_days: ([.[].metadata.creationTimestamp] | map(fromdateiso8601) | map((now - .) / 86400) | add / length | floor)
        })
    ')
    
    # –°–æ–∑–¥–∞–Ω–∏–µ cost report
    cat > $cost_report << COST_REPORT_EOF
{
  "report_timestamp": "$(date -Iseconds)",
  "cluster": "$(kubectl config current-context)",
  "cost_analysis": {
    "backup_distribution": $backup_stats,
    "estimated_monthly_costs": {
$(echo "$backup_stats" | jq -r '
    .[] | 
    {
        tier: .tier,
        estimated_gb: (.total_items * 0.001),  # –ü—Ä–∏–º–µ—Ä–Ω–∞—è –æ—Ü–µ–Ω–∫–∞
        cost_per_gb: (
            if .tier == "hot" then 0.25
            elif .tier == "warm" then 0.10
            elif .tier == "cold" then 0.04
            elif .tier == "glacier" then 0.01
            else 0.10 end
        )
    } | 
    "      \"\(.tier)\": {\"estimated_gb\": \(.estimated_gb), \"cost_per_gb\": \(.cost_per_gb), \"monthly_cost\": \(.estimated_gb * .cost_per_gb)}"
' | paste -sd, -)
    },
    "optimization_recommendations": [
$(velero backup get -o json | jq -r '
    .items[] | 
    select((.metadata.creationTimestamp | fromdateiso8601) < (now - 604800)) |
    select(.spec.storageLocation == "hot-tier-storage") |
    "      \"Move \(.metadata.name) to warm tier (age: \(((now - (.metadata.creationTimestamp | fromdateiso8601)) / 86400) | floor) days)\""
' | paste -sd, -)
    ]
  }
}
COST_REPORT_EOF
    
    log "üìä Cost analysis —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ $cost_report"
    
    # –í—ã–≤–æ–¥ –∫—Ä–∞—Ç–∫–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    local total_backups=$(echo "$backup_stats" | jq '[.[].count] | add')
    local estimated_monthly_cost=$(echo "$backup_stats" | jq '[.[] | (.total_items * 0.001) * (if .tier == "hot" then 0.25 elif .tier == "warm" then 0.10 elif .tier == "cold" then 0.04 elif .tier == "glacier" then 0.01 else 0.10 end)] | add')
    
    log "üíµ –ö—Ä–∞—Ç–∫–∞—è cost —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:"
    log "  üì¶ –í—Å–µ–≥–æ backup: $total_backups"
    log "  üí∞ –ü—Ä–∏–º–µ—Ä–Ω–∞—è –º–µ—Å—è—á–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å: \$$(printf "%.2f" $estimated_monthly_cost)"
}

# –§—É–Ω–∫—Ü–∏—è cleanup –ø–æ retention policies
execute_retention_cleanup() {
    log "üßπ –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ retention cleanup"
    
    local cleanup_count=0
    
    # Development tier cleanup (14 –¥–Ω–µ–π)
    velero backup get -l backup-tier=development -o json | jq -r --arg cutoff "$(date -d '14 days ago' -u +%Y-%m-%dT%H:%M:%SZ)" '
        .items[] | 
        select(.metadata.creationTimestamp < $cutoff) |
        select(.metadata.annotations["legal-hold"] != "true") |
        .metadata.name
    ' | while read backup_name; do
        if [ -n "$backup_name" ]; then
            log "üóëÔ∏è Development cleanup: $backup_name"
            velero backup delete $backup_name --confirm
            cleanup_count=$((cleanup_count + 1))
        fi
    done
    
    # Standard tier cleanup (180 –¥–Ω–µ–π)
    velero backup get -l backup-tier=standard -o json | jq -r --arg cutoff "$(date -d '180 days ago' -u +%Y-%m-%dT%H:%M:%SZ)" '
        .items[] | 
        select(.metadata.creationTimestamp < $cutoff) |
        select(.metadata.annotations["legal-hold"] != "true") |
        .metadata.name
    ' | while read backup_name; do
        if [ -n "$backup_name" ]; then
            log "üóëÔ∏è Standard cleanup: $backup_name"
            velero backup delete $backup_name --confirm
            cleanup_count=$((cleanup_count + 1))
        fi
    done
    
    log "‚úÖ Retention cleanup –∑–∞–≤–µ—Ä—à–µ–Ω: $cleanup_count backup —É–¥–∞–ª–µ–Ω–æ"
}

# –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è lifecycle monitoring
create_lifecycle_monitoring() {
    log "üìä –°–æ–∑–¥–∞–Ω–∏–µ lifecycle monitoring"
    
    kubectl apply -f - << MONITORING_EOF
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: backup-lifecycle-monitoring
  namespace: $MONITORING_NAMESPACE
spec:
  groups:
  - name: backup-lifecycle
    rules:
    - alert: BackupStorageUsageHigh
      expr: backup_storage_usage_percent > 85
      for: 15m
      labels:
        severity: warning
        component: backup-lifecycle
      annotations:
        summary: "Backup storage usage high"
        description: "Backup storage usage is {{ \$value }}%, exceeding 85% threshold"
    
    - alert: BackupRetentionPolicyViolation
      expr: backup_retention_violations_total > 0
      for: 5m
      labels:
        severity: critical
        component: backup-lifecycle
      annotations:
        summary: "Backup retention policy violation"
        description: "{{ \$value }} backups violate retention policies"
    
    - alert: BackupTieringFailed
      expr: backup_tier_transition_failures_total > 0
      for: 5m
      labels:
        severity: warning
        component: backup-lifecycle
      annotations:
        summary: "Backup tiering failed"
        description: "{{ \$value }} backup tier transitions failed"
    
    - alert: BackupCostBudgetExceeded
      expr: backup_monthly_cost_usd > backup_budget_limit_usd
      for: 0m
      labels:
        severity: warning
        component: backup-lifecycle
      annotations:
        summary: "Backup cost budget exceeded"
        description: "Monthly backup cost \${{ \$value }} exceeds budget limit"
    
    - alert: BackupLifecycleStuck
      expr: backup_lifecycle_last_run_seconds > 86400
      for: 30m
      labels:
        severity: critical
        component: backup-lifecycle
      annotations:
        summary: "Backup lifecycle automation stuck"
        description: "Backup lifecycle hasn't run for {{ \$value }} seconds"
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: backup-lifecycle-dashboard
  namespace: $MONITORING_NAMESPACE
  labels:
    grafana_dashboard: "1"
data:
  backup-lifecycle.json: |
    {
      "dashboard": {
        "title": "Backup Lifecycle Management",
        "tags": ["backup", "lifecycle", "storage"],
        "panels": [
          {
            "title": "Backup Distribution by Tier",
            "type": "piechart",
            "targets": [
              {"expr": "backup_count_by_tier", "legendFormat": "{{ tier }}"}
            ]
          },
          {
            "title": "Storage Costs by Tier",
            "type": "bargraph",
            "targets": [
              {"expr": "backup_monthly_cost_by_tier", "legendFormat": "{{ tier }}"}
            ]
          },
          {
            "title": "Backup Age Distribution",
            "type": "histogram",
            "targets": [
              {"expr": "backup_age_days_histogram", "legendFormat": "Age (days)"}
            ]
          },
          {
            "title": "Tier Transition Rate",
            "type": "timeseries",
            "targets": [
              {"expr": "rate(backup_tier_transitions_total[5m])", "legendFormat": "{{ source_tier }} ‚Üí {{ target_tier }}"}
            ]
          },
          {
            "title": "Retention Policy Compliance",
            "type": "stat",
            "targets": [
              {"expr": "backup_retention_compliance_percent", "legendFormat": "Compliance %"}
            ]
          },
          {
            "title": "Storage Usage Trend",
            "type": "timeseries",
            "targets": [
              {"expr": "backup_storage_usage_bytes by (tier)", "legendFormat": "{{ tier }}"}
            ]
          }
        ]
      }
    }
MONITORING_EOF
    
    log "‚úÖ Lifecycle monitoring —Å–æ–∑–¥–∞–Ω"
}

# –û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
main() {
    case "$1" in
        analyze)
            analyze_backup_ecosystem
            ;;
        policies)
            create_retention_policies
            ;;
        tiers)
            create_storage_tiers
            ;;
        tiering)
            execute_automated_tiering
            ;;
        costs)
            perform_cost_analysis
            ;;
        cleanup)
            execute_retention_cleanup
            ;;
        monitoring)
            create_lifecycle_monitoring
            ;;
        full)
            log "üöÄ –ó–∞–ø—É—Å–∫ –ø–æ–ª–Ω–æ–≥–æ backup lifecycle management"
            analyze_backup_ecosystem
            create_retention_policies
            create_storage_tiers
            execute_automated_tiering
            perform_cost_analysis
            execute_retention_cleanup
            create_lifecycle_monitoring
            log "üéâ Backup lifecycle management –Ω–∞—Å—Ç—Ä–æ–µ–Ω!"
            ;;
        *)
            echo "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: $0 {analyze|policies|tiers|tiering|costs|cleanup|monitoring|full}"
            echo "  analyze    - –ê–Ω–∞–ª–∏–∑ backup ecosystem"
            echo "  policies   - –°–æ–∑–¥–∞–Ω–∏–µ retention policies"
            echo "  tiers      - –°–æ–∑–¥–∞–Ω–∏–µ storage tiers"
            echo "  tiering    - –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ automated tiering"
            echo "  costs      - Cost analysis"
            echo "  cleanup    - Retention cleanup"
            echo "  monitoring - –°–æ–∑–¥–∞–Ω–∏–µ monitoring"
            echo "  full       - –ü–æ–ª–Ω–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ lifecycle"
            exit 1
            ;;
    esac
}

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
trap 'log "‚ùå –û—à–∏–±–∫–∞ –≤ backup lifecycle manager"; exit 1' ERR

# –ó–∞–ø—É—Å–∫ –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏
main "$@"
EOF

chmod +x backup-lifecycle-manager.sh
```

### **2. –°–æ–∑–¥–∞–Ω–∏–µ cost optimization framework:**
```bash
# –°–æ–∑–¥–∞—Ç—å —Å–∫—Ä–∏–ø—Ç backup-cost-optimizer.sh
cat << 'EOF' > backup-cost-optimizer.sh
#!/bin/bash

echo "üí∞ Backup Cost Optimization Framework"
echo "===================================="

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
COST_THRESHOLD_USD=100
OPTIMIZATION_TARGET_PERCENT=20

# –§—É–Ω–∫—Ü–∏—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

# –§—É–Ω–∫—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞ storage costs
analyze_storage_costs() {
    log "üíµ –ê–Ω–∞–ª–∏–∑ storage costs"
    
    local cost_analysis="/tmp/storage-cost-analysis-$TIMESTAMP.json"
    
    # –°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –æ backup storage
    cat > $cost_analysis << COST_ANALYSIS_EOF
{
  "analysis_timestamp": "$(date -Iseconds)",
  "cluster": "$(kubectl config current-context)",
  "storage_cost_analysis": {
    "current_usage": {
$(velero backup get -o json | jq -r '
    group_by(.spec.storageLocation // "unknown") | 
    map({
      storage_location: .[0].spec.storageLocation // "unknown",
      backup_count: length,
      estimated_size_gb: ([.[].status.progress.totalItems // 0] | add * 0.001),
      avg_age_days: ([.[].metadata.creationTimestamp] | map(fromdateiso8601) | map((now - .) / 86400) | add / length | floor),
      tier: (.[0].spec.storageLocation | split("-")[0] // "unknown")
    })[] |
    "      \"\(.storage_location)\": {\"count\": \(.backup_count), \"size_gb\": \(.estimated_size_gb), \"avg_age\": \(.avg_age_days), \"tier\": \"\(.tier)\"}"
' | paste -sd, -)
    },
    "cost_breakdown": {
$(velero backup get -o json | jq -r '
    group_by(.spec.storageLocation // "unknown") | 
    map({
      tier: (.[0].spec.storageLocation | split("-")[0] // "unknown"),
      size_gb: ([.[].status.progress.totalItems // 0] | add * 0.001),
      cost_per_gb: (
        if (.[0].spec.storageLocation | split("-")[0]) == "hot" then 0.25
        elif (.[0].spec.storageLocation | split("-")[0]) == "warm" then 0.10
        elif (.[0].spec.storageLocation | split("-")[0]) == "cold" then 0.04
        elif (.[0].spec.storageLocation | split("-")[0]) == "glacier" then 0.01
        else 0.10 end
      )
    }) | 
    map(. + {monthly_cost: (.size_gb * .cost_per_gb)}) |
    .[] |
    "      \"\(.tier)\": {\"size_gb\": \(.size_gb), \"cost_per_gb\": \(.cost_per_gb), \"monthly_cost\": \(.monthly_cost)}"
' | paste -sd, -)
    },
    "optimization_opportunities": [
$(velero backup get -o json | jq -r '
    .items[] | 
    select((.metadata.creationTimestamp | fromdateiso8601) < (now - 604800)) |
    select(.spec.storageLocation == "hot-tier-storage") |
    {
      backup: .metadata.name,
      age_days: ((now - (.metadata.creationTimestamp | fromdateiso8601)) / 86400 | floor),
      current_tier: "hot",
      recommended_tier: "warm",
      potential_savings: ((.status.progress.totalItems // 0) * 0.001 * 0.15)
    } |
    "      {\"backup\": \"\(.backup)\", \"age\": \(.age_days), \"current\": \"\(.current_tier)\", \"recommended\": \"\(.recommended_tier)\", \"savings\": \(.potential_savings)}"
' | paste -sd, -)
    ]
  }
}
COST_ANALYSIS_EOF
    
    log "üìä Cost analysis —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ $cost_analysis"
    
    # –í—ã–≤–æ–¥ –∫—Ä–∞—Ç–∫–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    local total_monthly_cost=$(jq -r '.storage_cost_analysis.cost_breakdown | to_entries | map(.value.monthly_cost) | add' $cost_analysis)
    local optimization_count=$(jq -r '.storage_cost_analysis.optimization_opportunities | length' $cost_analysis)
    
    log "üí∞ –¢–µ–∫—É—â–∞—è –º–µ—Å—è—á–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å: \$$(printf "%.2f" $total_monthly_cost)"
    log "üéØ –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏: $optimization_count"
    
    return 0
}

# –§—É–Ω–∫—Ü–∏—è automated cost optimization
execute_cost_optimization() {
    log "üéØ –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ automated cost optimization"
    
    local savings_total=0
    local optimizations_count=0
    
    # –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è 1: –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Å—Ç–∞—Ä—ã—Ö backup –≤ –±–æ–ª–µ–µ –¥–µ—à–µ–≤—ã–µ tiers
    velero backup get -o json | jq -r --arg cutoff "$(date -d '7 days ago' -u +%Y-%m-%dT%H:%M:%SZ)" '
        .items[] | 
        select(.metadata.creationTimestamp < $cutoff) |
        select(.spec.storageLocation == "hot-tier-storage") |
        select(.metadata.labels["backup-tier"] != "critical") |
        .metadata.name
    ' | while read backup_name; do
        if [ -n "$backup_name" ]; then
            log "üí∏ Cost optimization: $backup_name (hot ‚Üí warm)"
            
            # –†–∞—Å—á–µ—Ç —ç–∫–æ–Ω–æ–º–∏–∏
            local backup_size=$(velero backup describe $backup_name --details | grep "Total items" | awk '{print $3}' || echo "0")
            local estimated_gb=$(echo "$backup_size * 0.001" | bc -l 2>/dev/null || echo "0")
            local monthly_savings=$(echo "$estimated_gb * 0.15" | bc -l 2>/dev/null || echo "0")  # 0.25 - 0.10 = 0.15
            
            # –°–æ–∑–¥–∞–Ω–∏–µ backup –≤ warm tier
            velero backup create ${backup_name}-warm-optimized \
                --from-backup $backup_name \
                --storage-location warm-tier-storage \
                --labels "cost-optimized=true,original-backup=$backup_name" \
                --wait
            
            if [ $? -eq 0 ]; then
                # –£–¥–∞–ª–µ–Ω–∏–µ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ backup
                velero backup delete $backup_name --confirm
                
                savings_total=$(echo "$savings_total + $monthly_savings" | bc -l 2>/dev/null || echo "$savings_total")
                optimizations_count=$((optimizations_count + 1))
                
                log "‚úÖ Optimization completed: \$$(printf "%.2f" $monthly_savings) monthly savings"
            fi
        fi
    done
    
    # –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è 2: –£–¥–∞–ª–µ–Ω–∏–µ –∏–∑–±—ã—Ç–æ—á–Ω—ã—Ö development backup
    velero backup get -l backup-tier=development -o json | jq -r --arg cutoff "$(date -d '3 days ago' -u +%Y-%m-%dT%H:%M:%SZ)" '
        .items[] | 
        select(.metadata.creationTimestamp < $cutoff) |
        .metadata.name
    ' | while read backup_name; do
        if [ -n "$backup_name" ]; then
            log "üóëÔ∏è Development cleanup: $backup_name"
            
            # –†–∞—Å—á–µ—Ç —ç–∫–æ–Ω–æ–º–∏–∏ –æ—Ç —É–¥–∞–ª–µ–Ω–∏—è
            local backup_size=$(velero backup describe $backup_name --details | grep "Total items" | awk '{print $3}' || echo "0")
            local estimated_gb=$(echo "$backup_size * 0.001" | bc -l 2>/dev/null || echo "0")
            local monthly_savings=$(echo "$estimated_gb * 0.25" | bc -l 2>/dev/null || echo "0")  # –ü–æ–ª–Ω–∞—è —ç–∫–æ–Ω–æ–º–∏—è hot tier
            
            velero backup delete $backup_name --confirm
            
            savings_total=$(echo "$savings_total + $monthly_savings" | bc -l 2>/dev/null || echo "$savings_total")
            optimizations_count=$((optimizations_count + 1))
            
            log "‚úÖ Development cleanup: \$$(printf "%.2f" $monthly_savings) monthly savings"
        fi
    done
    
    # –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è 3: Compression –∏ deduplication
    compress_backup_data
    
    log "üí∞ Cost optimization –∑–∞–≤–µ—Ä—à–µ–Ω:"
    log "  üéØ –í—ã–ø–æ–ª–Ω–µ–Ω–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π: $optimizations_count"
    log "  üíµ –û–±—â–∞—è –º–µ—Å—è—á–Ω–∞—è —ç–∫–æ–Ω–æ–º–∏—è: \$$(printf "%.2f" $savings_total)"
}

# –§—É–Ω–∫—Ü–∏—è compression backup –¥–∞–Ω–Ω—ã—Ö
compress_backup_data() {
    log "üóúÔ∏è Compression backup –¥–∞–Ω–Ω—ã—Ö"
    
    # –ü–æ–∏—Å–∫ –Ω–µ—Å–∂–∞—Ç—ã—Ö backup –≤ storage
    kubectl get pv -l backup-storage=true -o json | jq -r '
        .items[] | 
        select(.spec.capacity.storage | test("[0-9]+Gi")) |
        {
            name: .metadata.name,
            size: .spec.capacity.storage,
            storage_class: .spec.storageClassName
        } |
        "\(.name):\(.size):\(.storage_class)"
    ' | while IFS=':' read pv_name size storage_class; do
        if [ -n "$pv_name" ]; then
            log "üóúÔ∏è –ê–Ω–∞–ª–∏–∑ compression –¥–ª—è PV: $pv_name ($size)"
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ compression
            local compression_ratio=$(check_compression_potential "$pv_name")
            
            if [ "$compression_ratio" != "0" ]; then
                log "üìä –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª compression: ${compression_ratio}% –¥–ª—è $pv_name"
                
                # –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ compression (–µ—Å–ª–∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è storage class)
                apply_compression_policy "$pv_name" "$storage_class"
            fi
        fi
    done
}

# –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ compression potential
check_compression_potential() {
    local pv_name=$1
    
    # –ü—Ä–∏–º–µ—Ä–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ compression potential
    # –í —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω—É–∂–Ω–æ –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ backup
    echo "30"  # 30% compression ratio
}

# –§—É–Ω–∫—Ü–∏—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è compression policy
apply_compression_policy() {
    local pv_name=$1
    local storage_class=$2
    
    log "üóúÔ∏è –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ compression policy –¥–ª—è $pv_name"
    
    # –°–æ–∑–¥–∞–Ω–∏–µ compressed storage class (–µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç)
    kubectl apply -f - << COMPRESSED_STORAGE_EOF
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: ${storage_class}-compressed
provisioner: dobs.csi.digitalocean.com
parameters:
  type: gp2
  compressed: "true"
  deduplication: "enabled"
allowVolumeExpansion: true
volumeBindingMode: WaitForFirstConsumer
COMPRESSED_STORAGE_EOF
    
    log "‚úÖ Compression policy –ø—Ä–∏–º–µ–Ω–µ–Ω–∞ –¥–ª—è $storage_class"
}

# –§—É–Ω–∫—Ü–∏—è budget monitoring
monitor_backup_budget() {
    log "üìä –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ backup budget"
    
    local current_month=$(date +%Y-%m)
    local budget_report="/tmp/backup-budget-report-$current_month.json"
    
    # –†–∞—Å—á–µ—Ç —Ç–µ–∫—É—â–∏—Ö –∑–∞—Ç—Ä–∞—Ç
    local current_costs=$(velero backup get -o json | jq -r '
        group_by(.spec.storageLocation // "unknown") | 
        map({
            tier: (.[0].spec.storageLocation | split("-")[0] // "unknown"),
            size_gb: ([.[].status.progress.totalItems // 0] | add * 0.001),
            cost_per_gb: (
                if (.[0].spec.storageLocation | split("-")[0]) == "hot" then 0.25
                elif (.[0].spec.storageLocation | split("-")[0]) == "warm" then 0.10
                elif (.[0].spec.storageLocation | split("-")[0]) == "cold" then 0.04
                elif (.[0].spec.storageLocation | split("-")[0]) == "glacier" then 0.01
                else 0.10 end
            )
        }) | 
        map(.size_gb * .cost_per_gb) | 
        add
    ')
    
    # –°–æ–∑–¥–∞–Ω–∏–µ budget report
    cat > $budget_report << BUDGET_REPORT_EOF
{
  "report_month": "$current_month",
  "budget_analysis": {
    "budget_limit_usd": $COST_THRESHOLD_USD,
    "current_monthly_cost_usd": $current_costs,
    "budget_utilization_percent": $(echo "scale=2; $current_costs / $COST_THRESHOLD_USD * 100" | bc -l),
    "remaining_budget_usd": $(echo "scale=2; $COST_THRESHOLD_USD - $current_costs" | bc -l),
    "budget_status": "$(if (( $(echo "$current_costs > $COST_THRESHOLD_USD" | bc -l) )); then echo "exceeded"; elif (( $(echo "$current_costs > $COST_THRESHOLD_USD * 0.8" | bc -l) )); then echo "warning"; else echo "ok"; fi)"
  },
  "recommendations": [
$(if (( $(echo "$current_costs > $COST_THRESHOLD_USD" | bc -l) )); then
    echo '    "Budget exceeded - immediate cost optimization required",'
    echo '    "Consider moving more backups to cold/glacier tiers",'
    echo '    "Review retention policies for development backups"'
else
    echo '    "Budget within limits",'
    echo '    "Continue monitoring cost trends"'
fi)
  ]
}
BUDGET_REPORT_EOF
    
    log "üìÑ Budget report —Å–æ–∑–¥–∞–Ω: $budget_report"
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ budget alerts
    if (( $(echo "$current_costs > $COST_THRESHOLD_USD" | bc -l) )); then
        log "üö® ALERT: Budget exceeded! Current: \$$(printf "%.2f" $current_costs), Limit: \$$COST_THRESHOLD_USD"
        send_budget_alert "exceeded" "$current_costs"
    elif (( $(echo "$current_costs > $COST_THRESHOLD_USD * 0.8" | bc -l) )); then
        log "‚ö†Ô∏è WARNING: Budget at 80%! Current: \$$(printf "%.2f" $current_costs), Limit: \$$COST_THRESHOLD_USD"
        send_budget_alert "warning" "$current_costs"
    else
        log "‚úÖ Budget OK: \$$(printf "%.2f" $current_costs) / \$$COST_THRESHOLD_USD"
    fi
}

# –§—É–Ω–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ budget alerts
send_budget_alert() {
    local alert_type=$1
    local current_cost=$2
    
    # –°–æ–∑–¥–∞–Ω–∏–µ alert –≤ Prometheus/Alertmanager
    kubectl apply -f - << BUDGET_ALERT_EOF
apiVersion: v1
kind: Event
metadata:
  name: backup-budget-alert-$(date +%s)
  namespace: velero
type: Warning
reason: BackupBudget${alert_type^}
message: "Backup budget $alert_type: \$$(printf "%.2f" $current_cost) / \$$COST_THRESHOLD_USD"
involvedObject:
  kind: ConfigMap
  name: backup-cost-monitoring
  namespace: velero
BUDGET_ALERT_EOF
    
    log "üìß Budget alert –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω: $alert_type"
}

# –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è cost monitoring dashboard
create_cost_monitoring_dashboard() {
    log "üìä –°–æ–∑–¥–∞–Ω–∏–µ cost monitoring dashboard"
    
    kubectl apply -f - << COST_DASHBOARD_EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: backup-cost-monitoring-dashboard
  namespace: monitoring
  labels:
    grafana_dashboard: "1"
data:
  backup-cost-monitoring.json: |
    {
      "dashboard": {
        "title": "Backup Cost Monitoring",
        "tags": ["backup", "cost", "optimization"],
        "panels": [
          {
            "title": "Monthly Cost Breakdown",
            "type": "piechart",
            "targets": [
              {"expr": "backup_monthly_cost_usd by (tier)", "legendFormat": "{{ tier }}"}
            ]
          },
          {
            "title": "Cost Trend",
            "type": "timeseries",
            "targets": [
              {"expr": "backup_total_monthly_cost_usd", "legendFormat": "Total Cost"},
              {"expr": "backup_budget_limit_usd", "legendFormat": "Budget Limit"}
            ]
          },
          {
            "title": "Budget Utilization",
            "type": "gauge",
            "targets": [
              {"expr": "backup_budget_utilization_percent", "legendFormat": "Budget %"}
            ],
            "thresholds": [
              {"color": "green", "value": 0},
              {"color": "yellow", "value": 80},
              {"color": "red", "value": 100}
            ]
          },
          {
            "title": "Cost Optimization Opportunities",
            "type": "table",
            "targets": [
              {"expr": "backup_optimization_potential_usd by (backup_name, current_tier, recommended_tier)", "legendFormat": "{{ backup_name }}"}
            ]
          },
          {
            "title": "Storage Efficiency",
            "type": "timeseries",
            "targets": [
              {"expr": "backup_compression_ratio_percent", "legendFormat": "Compression Ratio"},
              {"expr": "backup_deduplication_savings_percent", "legendFormat": "Deduplication Savings"}
            ]
          }
        ]
      }
    }
COST_DASHBOARD_EOF
    
    log "‚úÖ Cost monitoring dashboard —Å–æ–∑–¥–∞–Ω"
}

# –û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
main() {
    case "$1" in
        analyze)
            analyze_storage_costs
            ;;
        optimize)
            execute_cost_optimization
            ;;
        budget)
            monitor_backup_budget
            ;;
        dashboard)
            create_cost_monitoring_dashboard
            ;;
        full)
            log "üöÄ –ó–∞–ø—É—Å–∫ –ø–æ–ª–Ω–æ–π cost optimization"
            analyze_storage_costs
            execute_cost_optimization
            monitor_backup_budget
            create_cost_monitoring_dashboard
            log "üéâ Cost optimization –∑–∞–≤–µ—Ä—à–µ–Ω–∞!"
            ;;
        *)
            echo "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: $0 {analyze|optimize|budget|dashboard|full}"
            echo "  analyze   - –ê–Ω–∞–ª–∏–∑ storage costs"
            echo "  optimize  - –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ cost optimization"
            echo "  budget    - –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ budget"
            echo "  dashboard - –°–æ–∑–¥–∞–Ω–∏–µ cost dashboard"
            echo "  full      - –ü–æ–ª–Ω–∞—è cost optimization"
            exit 1
            ;;
    esac
}

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
trap 'log "‚ùå –û—à–∏–±–∫–∞ –≤ cost optimizer"; exit 1' ERR

# –ó–∞–ø—É—Å–∫ –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏
main "$@"
EOF

chmod +x backup-cost-optimizer.sh
```

## üìä **–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ backup lifecycle management:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              Backup Lifecycle Management                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Lifecycle Stages & Storage Tiers                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ Creation    ‚îÇ Hot Tier    ‚îÇ Warm Tier   ‚îÇ Cold/Glacier‚îÇ  ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ Auto    ‚îÇ ‚îú‚îÄ‚îÄ 7 days  ‚îÇ ‚îú‚îÄ‚îÄ 30 days ‚îÇ ‚îú‚îÄ‚îÄ 1+ year ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ Manual  ‚îÇ ‚îú‚îÄ‚îÄ SSD     ‚îÇ ‚îú‚îÄ‚îÄ Standard‚îÇ ‚îú‚îÄ‚îÄ Archive ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ Events  ‚îÇ ‚îú‚îÄ‚îÄ $0.25/GB‚îÇ ‚îú‚îÄ‚îÄ $0.10/GB‚îÇ ‚îú‚îÄ‚îÄ $0.01/GB‚îÇ  ‚îÇ
‚îÇ  ‚îÇ ‚îî‚îÄ‚îÄ Hooks   ‚îÇ ‚îî‚îÄ‚îÄ Fast    ‚îÇ ‚îî‚îÄ‚îÄ Medium  ‚îÇ ‚îî‚îÄ‚îÄ Slow    ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Automation & Optimization                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ Automated Tiering (Age-based Transitions)          ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ Retention Policies (Tier-specific Rules)           ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ Cost Optimization (Budget Monitoring)              ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ Compliance Management (Legal Hold, Audit)          ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚îî‚îÄ‚îÄ Monitoring & Alerting (Prometheus, Grafana)        ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üéØ **Best Practices –¥–ª—è backup lifecycle management:**

### **1. –°—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–æ–µ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ**
- –û–ø—Ä–µ–¥–µ–ª–∏—Ç–µ business requirements –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞ –¥–∞–Ω–Ω—ã—Ö
- –°–ø–ª–∞–Ω–∏—Ä—É–π—Ç–µ storage tiers –Ω–∞ –æ—Å–Ω–æ–≤–µ access patterns
- –ù–∞—Å—Ç—Ä–æ–π—Ç–µ automated retention policies
- –û–±–µ—Å–ø–µ—á—å—Ç–µ compliance —Å regulatory requirements

### **2. Cost optimization**
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ automated tiering –¥–ª—è —Å–Ω–∏–∂–µ–Ω–∏—è –∑–∞—Ç—Ä–∞—Ç
- –ú–æ–Ω–∏—Ç–æ—Ä—å—Ç–µ budget –∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–π—Ç–µ alerts
- –ü—Ä–∏–º–µ–Ω—è–π—Ç–µ compression –∏ deduplication
- –†–µ–≥—É–ª—è—Ä–Ω–æ –∞–Ω–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ optimization opportunities

### **3. Automation –∏ monitoring**
- –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∏—Ä—É–π—Ç–µ –≤—Å–µ lifecycle transitions
- –ù–∞—Å—Ç—Ä–æ–π—Ç–µ comprehensive monitoring
- –°–æ–∑–¥–∞–π—Ç–µ alerts –¥–ª—è –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π
- –í–µ–¥–∏—Ç–µ audit trail –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π

### **4. Compliance –∏ security**
- –û–±–µ—Å–ø–µ—á—å—Ç–µ encryption –¥–ª—è –≤—Å–µ—Ö tiers
- –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ legal hold requirements
- –î–æ–∫—É–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ –≤—Å–µ retention policies
- –†–µ–≥—É–ª—è—Ä–Ω–æ —Ç–µ—Å—Ç–∏—Ä—É–π—Ç–µ restore –ø—Ä–æ—Ü–µ–¥—É—Ä—ã

**–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∂–∏–∑–Ω–µ–Ω–Ω—ã–º —Ü–∏–∫–ª–æ–º backup –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω–æ –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –∑–∞—Ç—Ä–∞—Ç, –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è compliance –∏ –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏ backup —Å–∏—Å—Ç–µ–º—ã!**
