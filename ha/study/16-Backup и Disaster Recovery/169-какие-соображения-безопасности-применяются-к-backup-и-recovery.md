# 169. –ö–∞–∫–∏–µ —Å–æ–æ–±—Ä–∞–∂–µ–Ω–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è –∫ backup –∏ recovery?

## üéØ **–ß—Ç–æ —Ç–∞–∫–æ–µ backup security?**

**Backup security** ‚Äî —ç—Ç–æ –∫–æ–º–ø–ª–µ–∫—Å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –∑–∞—â–∏—Ç—ã —Ä–µ–∑–µ—Ä–≤–Ω—ã—Ö –∫–æ–ø–∏–π, –≤–∫–ª—é—á–∞—é—â–∞—è encryption at rest –∏ in transit, access control, immutable storage, anti-ransomware protection, audit logging, compliance management, threat detection, secure deletion –∏ –∑–∞—â–∏—Ç—É backup –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä—ã –æ—Ç –∫–æ–º–ø—Ä–æ–º–µ—Ç–∞—Ü–∏–∏ –Ω–∞ –≤—Å–µ—Ö —ç—Ç–∞–ø–∞—Ö –∂–∏–∑–Ω–µ–Ω–Ω–æ–≥–æ —Ü–∏–∫–ª–∞ –¥–∞–Ω–Ω—ã—Ö.

## üèóÔ∏è **–û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã backup security:**

### **1. Security Layers**
- **Encryption**: AES-256 —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –≤ –ø–æ–∫–æ–µ –∏ –ø—Ä–∏ –ø–µ—Ä–µ–¥–∞—á–µ
- **Access Control**: RBAC, MFA, privileged access management
- **Network Security**: Isolation, VPN, private endpoints
- **Threat Protection**: Anti-ransomware, malware scanning, anomaly detection
- **Compliance**: Audit trails, retention policies, regulatory compliance

### **2. Security Architecture**
- **Defense in Depth**: –ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–∞—è –∑–∞—â–∏—Ç–∞ backup —Å–∏—Å—Ç–µ–º—ã
- **Zero Trust**: –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–æ–≤ –∫ backup –¥–∞–Ω–Ω—ã–º
- **Immutable Storage**: Write-once-read-many backup —Ö—Ä–∞–Ω–∏–ª–∏—â–µ
- **Air-gapped Backups**: –§–∏–∑–∏—á–µ—Å–∫–∏ –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–ø–∏–∏ –¥–∞–Ω–Ω—ã—Ö

### **3. Threat Landscape**
- **Ransomware**: –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∏ —É–¥–∞–ª–µ–Ω–∏–µ backup –∑–ª–æ—É–º—ã—à–ª–µ–Ω–Ω–∏–∫–∞–º–∏
- **Data Exfiltration**: –ö—Ä–∞–∂–∞ sensitive –¥–∞–Ω–Ω—ã—Ö –∏–∑ backup
- **Insider Threats**: –ó–ª–æ—É–º—ã—à–ª–µ–Ω–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
- **Supply Chain Attacks**: –ö–æ–º–ø—Ä–æ–º–µ—Ç–∞—Ü–∏—è backup –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä—ã

## üìä **–ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–µ—Ä—ã –∏–∑ –≤–∞—à–µ–≥–æ HA –∫–ª–∞—Å—Ç–µ—Ä–∞:**

### **1. –ê–Ω–∞–ª–∏–∑ —Ç–µ–∫—É—â–µ–π backup security:**
```bash
# –ü—Ä–æ–≤–µ—Ä–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è backup
kubectl get secrets -n velero | grep -E "(encryption|tls|cert)"
velero backup describe $(velero backup get -o name | head -1) | grep -i encrypt

# –ê–Ω–∞–ª–∏–∑ RBAC –¥–ª—è backup –æ–ø–µ—Ä–∞—Ü–∏–π
kubectl get clusterrolebindings -o json | jq -r '.items[] | select(.roleRef.name | contains("backup") or contains("velero")) | "\(.metadata.name): \(.subjects[].name) -> \(.roleRef.name)"'

# –ü—Ä–æ–≤–µ—Ä–∫–∞ network policies –¥–ª—è backup
kubectl get networkpolicies -n velero -o yaml

# –ê—É–¥–∏—Ç backup storage locations
velero backup-location get -o json | jq -r '.items[] | "\(.metadata.name): \(.spec.provider) (\(.status.phase))"'
```

### **2. –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ security –ø—Ä–æ–±–ª–µ–º:**
```bash
# –ü–æ–∏—Å–∫ –Ω–µ–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö backup
velero backup get -o json | jq -r '.items[] | select(.spec.storageLocation | contains("unencrypted") or (.metadata.labels.encrypted // "false") == "false") | .metadata.name'

# –ü—Ä–æ–≤–µ—Ä–∫–∞ suspicious backup activity
kubectl get events --all-namespaces --field-selector type=Warning | grep -i backup | tail -10

# –ê–Ω–∞–ª–∏–∑ failed authentication attempts
kubectl logs -n velero deployment/velero | grep -i "auth\|permission\|denied" | tail -20

# –ü—Ä–æ–≤–µ—Ä–∫–∞ backup integrity violations
aws s3api list-objects-v2 --bucket hashfoundry-backup --query 'Contents[?LastModified>`2024-01-01`]' --output table 2>/dev/null || echo "AWS CLI not configured"
```

### **3. –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ security –º–µ—Ç—Ä–∏–∫:**
```bash
# –ü—Ä–æ–≤–µ—Ä–∫–∞ encryption status –≤—Å–µ—Ö backup
kubectl get backups -n velero -o json | jq -r 'group_by(.metadata.labels.encrypted // "unknown") | map({encrypted: .[0].metadata.labels.encrypted // "unknown", count: length}) | .[]'

# –ê–Ω–∞–ª–∏–∑ access patterns
kubectl get events --field-selector involvedObject.kind=Backup | awk '{print $1, $5, $6}' | sort | uniq -c

# –ü—Ä–æ–≤–µ—Ä–∫–∞ compliance status
velero backup get -o json | jq -r '.items[] | select(.metadata.annotations["compliance.required"] == "true") | "\(.metadata.name): \(.metadata.annotations["retention.policy"] // "undefined")"'
```

## üîÑ **–î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è comprehensive backup security:**

### **1. –°–æ–∑–¥–∞–Ω–∏–µ secure backup framework:**
```bash
# –°–æ–∑–¥–∞—Ç—å —Å–∫—Ä–∏–ø—Ç backup-security-manager.sh
cat << 'EOF' > backup-security-manager.sh
#!/bin/bash

echo "üîê Comprehensive Backup Security Manager"
echo "======================================="

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
VELERO_NAMESPACE="velero"
MONITORING_NAMESPACE="monitoring"
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
SECURITY_LOG="/var/log/backup-security-$TIMESTAMP.log"

# Encryption configurations
ENCRYPTION_ALGORITHM="AES-256-GCM"
KEY_ROTATION_DAYS=90
BACKUP_RETENTION_DAYS=2555  # 7 years for compliance

# –§—É–Ω–∫—Ü–∏—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a $SECURITY_LOG
}

# –§—É–Ω–∫—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞ security posture
analyze_backup_security_posture() {
    log "üîç –ê–Ω–∞–ª–∏–∑ backup security posture"
    
    local security_report="/tmp/backup-security-analysis-$TIMESTAMP.json"
    
    # Comprehensive security assessment
    cat > $security_report << SECURITY_ANALYSIS_EOF
{
  "analysis_timestamp": "$(date -Iseconds)",
  "cluster_context": "$(kubectl config current-context)",
  "security_assessment": {
    "encryption_status": {
$(velero backup get -o json | jq -r '
    group_by(.metadata.labels.encrypted // "unknown") | 
    map({
      encryption_status: .[0].metadata.labels.encrypted // "unknown",
      count: length,
      backup_names: [.[].metadata.name],
      total_size_estimate: ([.[].status.progress.totalItems // 0] | add)
    })[] | 
    "      \"\(.encryption_status)\": {\"count\": \(.count), \"total_items\": \(.total_size_estimate), \"backups\": \(.backup_names)}"
' | paste -sd, -)
    },
    "access_control": {
      "rbac_bindings": $(kubectl get clusterrolebindings -o json | jq '[.items[] | select(.roleRef.name | contains("backup") or contains("velero")) | {name: .metadata.name, subjects: .subjects, role: .roleRef.name}]'),
      "service_accounts": $(kubectl get serviceaccounts -n $VELERO_NAMESPACE -o json | jq '[.items[] | {name: .metadata.name, secrets: .secrets}]'),
      "network_policies": $(kubectl get networkpolicies -n $VELERO_NAMESPACE -o json | jq '[.items[] | {name: .metadata.name, spec: .spec}]')
    },
    "storage_security": {
$(kubectl get backupstoragelocations -n $VELERO_NAMESPACE -o json | jq -r '
    .items[] | 
    {
      name: .metadata.name,
      provider: .spec.provider,
      encryption_config: .spec.config.serverSideEncryption // "none",
      access_mode: .spec.accessMode,
      status: .status.phase
    } | 
    "      \"\(.name)\": {\"provider\": \"\(.provider)\", \"encryption\": \"\(.encryption_config)\", \"access_mode\": \"\(.access_mode)\", \"status\": \"\(.status)\"}"
' | paste -sd, -)
    },
    "compliance_status": {
$(velero backup get -o json | jq -r '
    group_by(.metadata.annotations["compliance.required"] // "unknown") | 
    map({
      compliance_required: .[0].metadata.annotations["compliance.required"] // "unknown",
      count: length,
      retention_policies: [.[].metadata.annotations["retention.policy"] // "undefined"] | unique
    })[] | 
    "      \"\(.compliance_required)\": {\"count\": \(.count), \"retention_policies\": \(.retention_policies)}"
' | paste -sd, -)
    }
  },
  "security_recommendations": [
$(velero backup get -o json | jq -r '
    .items[] | 
    select((.metadata.labels.encrypted // "false") == "false") |
    "    \"Encrypt backup: \(.metadata.name)\""
' | paste -sd, -)
  ]
}
SECURITY_ANALYSIS_EOF
    
    log "üìÑ Security analysis —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ $security_report"
    
    # –ö—Ä–∞—Ç–∫–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    local total_backups=$(velero backup get -o json | jq '.items | length')
    local encrypted_backups=$(velero backup get -o json | jq '[.items[] | select((.metadata.labels.encrypted // "false") == "true")] | length')
    local compliance_backups=$(velero backup get -o json | jq '[.items[] | select(.metadata.annotations["compliance.required"] == "true")] | length')
    
    log "üîê Security —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:"
    log "  üì¶ –í—Å–µ–≥–æ backup: $total_backups"
    log "  üîí –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö: $encrypted_backups"
    log "  üìã Compliance: $compliance_backups"
    
    return 0
}

# –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è encryption framework
create_encryption_framework() {
    log "üîê –°–æ–∑–¥–∞–Ω–∏–µ encryption framework"
    
    # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è master encryption key
    local master_key=$(openssl rand -hex 32)
    local key_id="backup-master-key-$(date +%s)"
    
    # –°–æ–∑–¥–∞–Ω–∏–µ encryption secrets
    kubectl apply -f - << ENCRYPTION_SECRETS_EOF
apiVersion: v1
kind: Secret
metadata:
  name: backup-encryption-keys
  namespace: $VELERO_NAMESPACE
  labels:
    component: backup-security
    encryption: master-key
type: Opaque
data:
  master-key: $(echo -n "$master_key" | base64 -w 0)
  key-id: $(echo -n "$key_id" | base64 -w 0)
  algorithm: $(echo -n "$ENCRYPTION_ALGORITHM" | base64 -w 0)
  created: $(echo -n "$(date -u +%Y-%m-%dT%H:%M:%SZ)" | base64 -w 0)
---
apiVersion: v1
kind: Secret
metadata:
  name: backup-tls-certificates
  namespace: $VELERO_NAMESPACE
  labels:
    component: backup-security
    encryption: transport
type: kubernetes.io/tls
data:
  tls.crt: $(openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /tmp/backup.key -out /tmp/backup.crt -subj "/CN=backup.hashfoundry.local" && cat /tmp/backup.crt | base64 -w 0)
  tls.key: $(cat /tmp/backup.key | base64 -w 0)
ENCRYPTION_SECRETS_EOF
    
    # –°–æ–∑–¥–∞–Ω–∏–µ encrypted storage locations
    kubectl apply -f - << ENCRYPTED_STORAGE_EOF
apiVersion: velero.io/v1
kind: BackupStorageLocation
metadata:
  name: encrypted-primary-storage
  namespace: $VELERO_NAMESPACE
  labels:
    security-tier: "high"
    encryption: "enabled"
spec:
  provider: aws
  objectStorage:
    bucket: hashfoundry-backup-encrypted
    prefix: encrypted-primary
  config:
    region: fra1
    serverSideEncryption: AES256
    kmsKeyId: arn:aws:kms:fra1:123456789012:key/backup-encryption-key
    s3ForcePathStyle: "false"
  accessMode: ReadWrite
---
apiVersion: velero.io/v1
kind: BackupStorageLocation
metadata:
  name: immutable-compliance-storage
  namespace: $VELERO_NAMESPACE
  labels:
    security-tier: "maximum"
    encryption: "enabled"
    compliance: "required"
spec:
  provider: aws
  objectStorage:
    bucket: hashfoundry-backup-immutable
    prefix: compliance-backups
  config:
    region: fra1
    serverSideEncryption: AES256
    kmsKeyId: arn:aws:kms:fra1:123456789012:key/compliance-encryption-key
    objectLockEnabled: "true"
    objectLockRetentionMode: "GOVERNANCE"
    objectLockRetentionDays: "$BACKUP_RETENTION_DAYS"
  accessMode: ReadOnly
ENCRYPTED_STORAGE_EOF
    
    log "‚úÖ Encryption framework —Å–æ–∑–¥–∞–Ω"
}

# –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è access control
create_access_control_framework() {
    log "üõ°Ô∏è –°–æ–∑–¥–∞–Ω–∏–µ access control framework"
    
    kubectl apply -f - << ACCESS_CONTROL_EOF
# Backup Security ServiceAccount
apiVersion: v1
kind: ServiceAccount
metadata:
  name: backup-security-operator
  namespace: $VELERO_NAMESPACE
  labels:
    component: backup-security
---
# Backup Admin Role (Full Access)
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: backup-admin
  labels:
    component: backup-security
rules:
- apiGroups: ["velero.io"]
  resources: ["*"]
  verbs: ["*"]
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["create", "get", "list", "watch", "update", "patch", "delete"]
  resourceNames: ["backup-encryption-keys", "cloud-credentials", "backup-tls-certificates"]
- apiGroups: ["snapshot.storage.k8s.io"]
  resources: ["*"]
  verbs: ["*"]
---
# Backup Operator Role (Limited Access)
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: backup-operator
  labels:
    component: backup-security
rules:
- apiGroups: ["velero.io"]
  resources: ["backups", "restores", "schedules"]
  verbs: ["create", "get", "list", "watch", "update", "patch"]
- apiGroups: ["velero.io"]
  resources: ["backups"]
  verbs: ["delete"]
  resourceNames: []  # Specific backup names only
- apiGroups: [""]
  resources: ["persistentvolumes", "persistentvolumeclaims"]
  verbs: ["get", "list", "watch"]
---
# Backup Viewer Role (Read-Only)
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: backup-viewer
  labels:
    component: backup-security
rules:
- apiGroups: ["velero.io"]
  resources: ["backups", "restores", "schedules", "backupstoragelocations"]
  verbs: ["get", "list", "watch"]
---
# Emergency Backup Role (Break-Glass Access)
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: backup-emergency
  labels:
    component: backup-security
    emergency: "true"
rules:
- apiGroups: ["velero.io"]
  resources: ["*"]
  verbs: ["*"]
- apiGroups: [""]
  resources: ["*"]
  verbs: ["*"]
---
# Production Backup Access
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: backup-production-access
  namespace: production
  labels:
    component: backup-security
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: backup-operator
subjects:
- kind: ServiceAccount
  name: backup-security-operator
  namespace: $VELERO_NAMESPACE
---
# Network Security Policy
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: backup-network-security
  namespace: $VELERO_NAMESPACE
  labels:
    component: backup-security
spec:
  podSelector:
    matchLabels:
      app: velero
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: monitoring
    - namespaceSelector:
        matchLabels:
          name: kube-system
    ports:
    - protocol: TCP
      port: 8080  # Metrics
  egress:
  - to: []
    ports:
    - protocol: TCP
      port: 443   # HTTPS to cloud storage
    - protocol: TCP
      port: 53    # DNS
  - to: []
    ports:
    - protocol: UDP
      port: 53    # DNS
ACCESS_CONTROL_EOF
    
    log "‚úÖ Access control framework —Å–æ–∑–¥–∞–Ω"
}

# –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è threat protection
create_threat_protection_framework() {
    log "üö® –°–æ–∑–¥–∞–Ω–∏–µ threat protection framework"
    
    kubectl apply -f - << THREAT_PROTECTION_EOF
# Anti-Ransomware Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: backup-threat-protection
  namespace: $VELERO_NAMESPACE
  labels:
    component: backup-security
data:
  threat-protection-config.yaml: |
    threat_protection:
      anti_ransomware:
        enabled: true
        immutable_backups: true
        air_gapped_copies: true
        anomaly_detection: true
        rapid_backup_detection_threshold: 10  # backups per hour
        mass_deletion_threshold: 5  # deletions per day
      
      malware_protection:
        enabled: true
        scan_on_restore: true
        quarantine_suspicious: true
        scan_engines: ["clamav", "defender"]
      
      access_monitoring:
        enabled: true
        failed_auth_threshold: 3
        privilege_escalation_detection: true
        unusual_access_pattern_detection: true
      
      compliance_enforcement:
        enabled: true
        retention_policy_enforcement: true
        encryption_requirement: true
        audit_trail_requirement: true
---
# Backup Monitoring Rules
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: backup-security-monitoring
  namespace: $MONITORING_NAMESPACE
  labels:
    component: backup-security
spec:
  groups:
  - name: backup-security
    rules:
    - alert: BackupRansomwareActivity
      expr: increase(backup_creation_rate[1h]) > 10
      for: 5m
      labels:
        severity: critical
        component: backup-security
        threat: ransomware
      annotations:
        summary: "Potential ransomware activity detected"
        description: "Unusual backup creation rate: {{ \$value }} backups in 1 hour"
    
    - alert: BackupMassDeletion
      expr: increase(backup_deletion_rate[1d]) > 5
      for: 0m
      labels:
        severity: critical
        component: backup-security
        threat: ransomware
      annotations:
        summary: "Mass backup deletion detected"
        description: "{{ \$value }} backups deleted in 24 hours"
    
    - alert: BackupEncryptionFailure
      expr: backup_encryption_failures_total > 0
      for: 0m
      labels:
        severity: warning
        component: backup-security
      annotations:
        summary: "Backup encryption failure"
        description: "{{ \$value }} backup encryption failures detected"
    
    - alert: BackupUnauthorizedAccess
      expr: backup_unauthorized_access_attempts_total > 3
      for: 5m
      labels:
        severity: warning
        component: backup-security
        threat: unauthorized-access
      annotations:
        summary: "Unauthorized backup access attempts"
        description: "{{ \$value }} unauthorized access attempts to backup system"
    
    - alert: BackupIntegrityViolation
      expr: backup_integrity_check_failures_total > 0
      for: 0m
      labels:
        severity: critical
        component: backup-security
        threat: data-corruption
      annotations:
        summary: "Backup integrity violation"
        description: "{{ \$value }} backup integrity check failures"
    
    - alert: BackupComplianceViolation
      expr: backup_compliance_violations_total > 0
      for: 0m
      labels:
        severity: warning
        component: backup-security
        compliance: violation
      annotations:
        summary: "Backup compliance violation"
        description: "{{ \$value }} backup compliance violations detected"
THREAT_PROTECTION_EOF
    
    log "‚úÖ Threat protection framework —Å–æ–∑–¥–∞–Ω"
}

# –§—É–Ω–∫—Ü–∏—è automated security scanning
execute_security_scanning() {
    log "üîç –í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ automated security scanning"
    
    local scan_results="/tmp/backup-security-scan-$TIMESTAMP.json"
    local threats_detected=0
    
    # –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ ransomware –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
    log "ü¶† –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ ransomware –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã"
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–Ω–æ–º–∞–ª—å–Ω–æ–π backup –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
    local recent_backups=$(velero backup get -o json | \
        jq --arg since "$(date -d '1 hour ago' -u +%Y-%m-%dT%H:%M:%SZ)" \
        '[.items[] | select(.metadata.creationTimestamp > $since)] | length')
    
    if [ $recent_backups -gt 10 ]; then
        log "‚ö†Ô∏è THREAT: –ê–Ω–æ–º–∞–ª—å–Ω–∞—è backup –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å - $recent_backups backup –∑–∞ —á–∞—Å"
        threats_detected=$((threats_detected + 1))
        trigger_security_alert "ransomware_activity" "excessive_backup_creation:$recent_backups"
    fi
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ mass deletion events
    local recent_deletions=$(grep "backup.*delete" /var/log/velero.log 2>/dev/null | \
        grep "$(date +%Y-%m-%d)" | wc -l || echo "0")
    
    if [ $recent_deletions -gt 5 ]; then
        log "‚ö†Ô∏è THREAT: Mass deletion detected - $recent_deletions —É–¥–∞–ª–µ–Ω–∏–π"
        threats_detected=$((threats_detected + 1))
        trigger_security_alert "mass_deletion" "backup_deletions:$recent_deletions"
    fi
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ unauthorized access attempts
    local auth_failures=$(kubectl get events --field-selector type=Warning | \
        grep -i "auth\|permission\|denied" | \
        grep "$(date +%Y-%m-%d)" | wc -l)
    
    if [ $auth_failures -gt 3 ]; then
        log "‚ö†Ô∏è THREAT: Unauthorized access attempts - $auth_failures –ø–æ–ø—ã—Ç–æ–∫"
        threats_detected=$((threats_detected + 1))
        trigger_security_alert "unauthorized_access" "auth_failures:$auth_failures"
    fi
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ encryption compliance
    local unencrypted_backups=$(velero backup get -o json | \
        jq '[.items[] | select((.metadata.labels.encrypted // "false") == "false")] | length')
    
    if [ $unencrypted_backups -gt 0 ]; then
        log "‚ö†Ô∏è COMPLIANCE: –ù–µ–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ backup - $unencrypted_backups —à—Ç—É–∫"
        threats_detected=$((threats_detected + 1))
        trigger_security_alert "encryption_compliance" "unencrypted_backups:$unencrypted_backups"
    fi
    
    # –°–æ–∑–¥–∞–Ω–∏–µ scan report
    cat > $scan_results << SCAN_REPORT_EOF
{
  "scan_timestamp": "$(date -Iseconds)",
  "cluster": "$(kubectl config current-context)",
  "security_scan_results": {
    "threats_detected": $threats_detected,
    "ransomware_indicators": {
      "excessive_backup_creation": $recent_backups,
      "mass_deletions": $recent_deletions,
      "risk_level": "$(if [ $recent_backups -gt 10 ] || [ $recent_deletions -gt 5 ]; then echo "high"; elif [ $recent_backups -gt 5 ] || [ $recent_deletions -gt 2 ]; then echo "medium"; else echo "low"; fi)"
    },
    "access_security": {
      "auth_failures": $auth_failures,
      "unauthorized_attempts": "$(if [ $auth_failures -gt 3 ]; then echo "detected"; else echo "none"; fi)"
    },
    "compliance_status": {
      "unencrypted_backups": $unencrypted_backups,
      "encryption_compliance": "$(if [ $unencrypted_backups -eq 0 ]; then echo "compliant"; else echo "violation"; fi)"
    }
  },
  "recommendations": [
$(if [ $recent_backups -gt 10 ]; then echo '    "Investigate excessive backup creation activity",'; fi)
$(if [ $recent_deletions -gt 5 ]; then echo '    "Review mass deletion events for potential ransomware",'; fi)
$(if [ $auth_failures -gt 3 ]; then echo '    "Strengthen access controls and investigate auth failures",'; fi)
$(if [ $unencrypted_backups -gt 0 ]; then echo '    "Encrypt all backup data to meet compliance requirements",'; fi)
    "Continue regular security monitoring"
  ]
}
SCAN_REPORT_EOF
    
    log "üìÑ Security scan report: $scan_results"
    log "üéØ Threats detected: $threats_detected"
    
    return $threats_detected
}

# –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è compliance framework
create_compliance_framework() {
    log "üìã –°–æ–∑–¥–∞–Ω–∏–µ compliance framework"
    
    kubectl apply -f - << COMPLIANCE_FRAMEWORK_EOF
# Compliance Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: backup-compliance-config
  namespace: $VELERO_NAMESPACE
  labels:
    component: backup-security
    compliance: required
data:
  compliance-policies.yaml: |
    compliance_policies:
      gdpr:
        enabled: true
        data_retention_days: 2555  # 7 years
        encryption_required: true
        right_to_erasure: true
        data_portability: true
        audit_trail_required: true
      
      sox:
        enabled: true
        financial_data_retention_days: 2555  # 7 years
        immutable_storage_required: true
        access_controls_required: true
        change_management_required: true
      
      hipaa:
        enabled: false  # Enable if healthcare data
        phi_encryption_required: true
        access_logging_required: true
        breach_notification_required: true
      
      pci_dss:
        enabled: false  # Enable if payment data
        cardholder_data_protection: true
        access_restriction_required: true
        vulnerability_management: true
---
# Compliance Monitoring
apiVersion: batch/v1
kind: CronJob
metadata:
  name: backup-compliance-audit
  namespace: $VELERO_NAMESPACE
  labels:
    component: backup-security
    compliance: audit
spec:
  schedule: "0 2 * * *"  # Daily at 2 AM
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: backup-security-operator
          containers:
          - name: compliance-auditor
            image: alpine/curl:latest
            command:
            - /bin/sh
            - -c
            - |
              echo "Running backup compliance audit..."
              
              # Check encryption compliance
              UNENCRYPTED=\$(kubectl get backups -n velero -o json | jq '[.items[] | select((.metadata.labels.encrypted // "false") == "false")] | length')
              
              # Check retention compliance
              EXPIRED=\$(kubectl get backups -n velero -o json | jq --arg cutoff "\$(date -d '7 years ago' -u +%Y-%m-%dT%H:%M:%SZ)" '[.items[] | select(.metadata.creationTimestamp < \$cutoff)] | length')
              
              # Generate compliance report
              cat > /tmp/compliance-report.json << EOF
              {
                "audit_date": "\$(date -u +%Y-%m-%dT%H:%M:%SZ)",
                "compliance_status": {
                  "encryption_violations": \$UNENCRYPTED,
                  "retention_violations": \$EXPIRED,
                  "overall_status": "\$(if [ \$UNENCRYPTED -eq 0 ] && [ \$EXPIRED -eq 0 ]; then echo "compliant"; else echo "violations_detected"; fi)"
                }
              }
              EOF
              
              echo "Compliance audit completed"
          restartPolicy: OnFailure
COMPLIANCE_FRAMEWORK_EOF
    
    log "‚úÖ Compliance framework —Å–æ–∑–¥–∞–Ω"
}

# –§—É–Ω–∫—Ü–∏—è —Ç—Ä–∏–≥–≥–µ—Ä–∞ security alerts
trigger_security_alert() {
    local alert_type=$1
    local details=$2
    
    log "üö® SECURITY ALERT: $alert_type - $details"
    
    # –°–æ–∑–¥–∞–Ω–∏–µ Kubernetes Event
    kubectl create event backup-security-alert-$(date +%s) \
        --type=Warning \
        --reason="BackupSecurityAlert" \
        --message="Security alert: $alert_type - $details" \
        --namespace=$VELERO_NAMESPACE
    
    # –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ monitoring system
    if command -v curl &> /dev/null && [ -n "$SLACK_WEBHOOK_URL" ]; then
        curl -X POST -H 'Content-type: application/json' \
            --data "{
                \"text\":\"üö® BACKUP SECURITY ALERT\",
                \"attachments\":[{
                    \"color\":\"danger\",
                    \"fields\":[{
                        \"title\":\"Alert Type\",
                        \"value\":\"$alert_type\",
                        \"short\":true
                    },{
                        \"title\":\"Details\",
                        \"value\":\"$details\",
                        \"short\":true
                    },{
                        \"title\":\"Cluster\",
                        \"value\":\"$(kubectl config current-context)\",
                        \"short\":true
                    },{
                        \"title\":\"Timestamp\",
                        \"value\":\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",
                        \"short\":true
                    }]
                }]
            }" \
            "$SLACK_WEBHOOK_URL"
    fi
    
    # –°–æ–∑–¥–∞–Ω–∏–µ audit –∑–∞–ø–∏—Å–∏
    cat >> /var/log/backup-security-alerts.audit << AUDIT_EOF
{
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "alert_type": "$alert_type",
  "details": "$details",
  "cluster": "$(kubectl config current-context)",
  "severity": "high"
}
AUDIT_EOF
}

# –û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
main() {
    case "$1" in
        analyze)
            analyze_backup_security_posture
            ;;
        encryption)
            create_encryption_framework
            ;;
        access-control)
            create_access_control_framework
            ;;
        threat-protection)
            create_threat_protection_framework
            ;;
        scan)
            execute_security_scanning
            ;;
        compliance)
            create_compliance_framework
            ;;
        full)
            log "üöÄ –ó–∞–ø—É—Å–∫ –ø–æ–ª–Ω–æ–≥–æ backup security framework"
            analyze_backup_security_posture
            create_encryption_framework
            create_access_control_framework
            create_threat_protection_framework
            execute_security_scanning
            create_compliance_framework
            log "üéâ Backup security framework –Ω–∞—Å—Ç—Ä–æ–µ–Ω!"
            ;;
        *)
            echo "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: $0 {analyze|encryption|access-control|threat-protection|scan|compliance|full}"
            echo "  analyze          - –ê–Ω–∞–ª–∏–∑ security posture"
            echo "  encryption       - –°–æ–∑–¥–∞–Ω–∏–µ encryption framework"
            echo "  access-control   - –°–æ–∑–¥–∞–Ω–∏–µ access control"
            echo "  threat-protection - –°–æ–∑–¥–∞–Ω–∏–µ threat protection"
            echo "  scan            - Security scanning"
            echo "  compliance      - Compliance framework"
            echo "  full            - –ü–æ–ª–Ω–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ security"
            exit 1
            ;;
    esac
}

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
trap 'log "‚ùå –û—à–∏–±–∫–∞ –≤ backup security manager"; exit 1' ERR

# –ó–∞–ø—É—Å–∫ –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏
main "$@"
EOF

chmod +x backup-security-manager.sh
```

### **2. –°–æ–∑–¥–∞–Ω–∏–µ incident response framework:**
```bash
# –°–æ–∑–¥–∞—Ç—å —Å–∫—Ä–∏–ø—Ç backup-incident-response.sh
cat << 'EOF' > backup-incident-response.sh
#!/bin/bash

echo "üö® Backup Security Incident Response"
echo "===================================="

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
INCIDENT_ID="INC-$(date +%Y%m%d-%H%M%S)"
INCIDENT_LOG="/var/log/backup-incidents-$INCIDENT_ID.log"
QUARANTINE_NAMESPACE="backup-quarantine"

# –§—É–Ω–∫—Ü–∏—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a $INCIDENT_LOG
}

# –§—É–Ω–∫—Ü–∏—è ransomware response
ransomware_incident_response() {
    log "üö® RANSOMWARE INCIDENT RESPONSE ACTIVATED"
    
    # –ù–µ–º–µ–¥–ª–µ–Ω–Ω–∞—è –∏–∑–æ–ª—è—Ü–∏—è backup —Å–∏—Å—Ç–µ–º—ã
    log "üîí –ò–∑–æ–ª—è—Ü–∏—è backup —Å–∏—Å—Ç–µ–º—ã"
    
    # –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –≤—Å–µ—Ö backup –æ–ø–µ—Ä–∞—Ü–∏–π
    kubectl patch deployment velero -n velero -p '{"spec":{"replicas":0}}'
    
    # –°–æ–∑–¥–∞–Ω–∏–µ emergency backup –ø–µ—Ä–µ–¥ –∏–∑–æ–ª—è—Ü–∏–µ–π
    log "üì¶ –°–æ–∑–¥–∞–Ω–∏–µ emergency backup"
    velero backup create emergency-backup-$(date +%s) \
        --storage-location immutable-compliance-storage \
        --wait --timeout 10m
    
    # –ò–∑–æ–ª—è—Ü–∏—è network traffic
    kubectl apply -f - << ISOLATION_POLICY_EOF
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: backup-emergency-isolation
  namespace: velero
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
  # –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –≤—Å–µ–≥–æ —Ç—Ä–∞—Ñ–∏–∫–∞
ISOLATION_POLICY_EOF
    
    # –°–æ–∑–¥–∞–Ω–∏–µ forensic snapshot
    create_forensic_snapshot
    
    # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ security team
    notify_security_team "ransomware_detected" "Backup system isolated"
    
    log "‚úÖ Ransomware response completed"
}

# –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è forensic snapshot
create_forensic_snapshot() {
    log "üîç –°–æ–∑–¥–∞–Ω–∏–µ forensic snapshot"
    
    # Snapshot –≤—Å–µ—Ö backup PVs
    kubectl get pv -l backup-storage=true -o json | \
        jq -r '.items[].metadata.name' | \
        while read pv_name; do
            log "üì∏ Forensic snapshot: $pv_name"
            
            kubectl apply -f - << FORENSIC_SNAPSHOT_EOF
apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshot
metadata:
  name: forensic-${pv_name}-$(date +%s)
  namespace: velero
  labels:
    forensic: "true"
    incident-id: "$INCIDENT_ID"
spec:
  source:
    persistentVolumeClaimName: $pv_name
  volumeSnapshotClassName: csi-do-snapshots
FORENSIC_SNAPSHOT_EOF
        done
    
    log "‚úÖ Forensic snapshots —Å–æ–∑–¥–∞–Ω—ã"
}

# –§—É–Ω–∫—Ü–∏—è data breach response
data_breach_incident_response() {
    local breach_type=$1
    
    log "üö® DATA BREACH INCIDENT RESPONSE: $breach_type"
    
    # –ù–µ–º–µ–¥–ª–µ–Ω–Ω–∞—è —Ä–æ—Ç–∞—Ü–∏—è –≤—Å–µ—Ö credentials
    log "üîë –†–æ—Ç–∞—Ü–∏—è credentials"
    
    # –†–æ—Ç–∞—Ü–∏—è cloud credentials
    rotate_cloud_credentials
    
    # –†–æ—Ç–∞—Ü–∏—è encryption keys
    rotate_encryption_keys
    
    # Audit –≤—Å–µ—Ö access logs
    audit_access_logs
    
    # –°–æ–∑–¥–∞–Ω–∏–µ breach report
    create_breach_report "$breach_type"
    
    log "‚úÖ Data breach response completed"
}

# –§—É–Ω–∫—Ü–∏—è —Ä–æ—Ç–∞—Ü–∏–∏ cloud credentials
rotate_cloud_credentials() {
    log "üîÑ –†–æ—Ç–∞—Ü–∏—è cloud credentials"
    
    # –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤—ã—Ö AWS credentials
    local new_access_key=$(aws iam create-access-key --user-name velero-backup-user \
        --query 'AccessKey.AccessKeyId' --output text 2>/dev/null || echo "manual-rotation-required")
    
    if [ "$new_access_key" != "manual-rotation-required" ]; then
        local new_secret_key=$(aws iam create-access-key --user-name velero-backup-user \
            --query 'AccessKey.SecretAccessKey' --output text)
        
        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ Kubernetes Secret
        kubectl create secret generic cloud-credentials \
            --from-literal=cloud="[default]
aws_access_key_id=$new_access_key
aws_secret_access_key=$new_secret_key" \
            --namespace=velero \
            --dry-run=client -o yaml | kubectl apply -f -
        
        log "‚úÖ Cloud credentials –æ–±–Ω–æ–≤–ª–µ–Ω—ã"
    else
        log "‚ö†Ô∏è Manual cloud credentials rotation required"
    fi
}

# –§—É–Ω–∫—Ü–∏—è —Ä–æ—Ç–∞—Ü–∏–∏ encryption keys
rotate_encryption_keys() {
    log "üîê –†–æ—Ç–∞—Ü–∏—è encryption keys"
    
    # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ master key
    local new_master_key=$(openssl rand -hex 32)
    local new_key_id="emergency-key-$(date +%s)"
    
    # –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ encryption secret
    kubectl create secret generic backup-encryption-keys-emergency \
        --from-literal=master-key="$new_master_key" \
        --from-literal=key-id="$new_key_id" \
        --from-literal=created="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
        --namespace=velero
    
    # Backup —Å—Ç–∞—Ä–æ–≥–æ –∫–ª—é—á–∞ –¥–ª—è recovery
    kubectl get secret backup-encryption-keys -n velero -o yaml > \
        /tmp/old-encryption-keys-$INCIDENT_ID.yaml
    
    # –ó–∞–º–µ–Ω–∞ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∫–ª—é—á–∞
    kubectl delete secret backup-encryption-keys -n velero
    kubectl create secret generic backup-encryption-keys \
        --from-literal=master-key="$new_master_key" \
        --from-literal=key-id="$new_key_id" \
        --from-literal=created="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
        --namespace=velero
    
    log "‚úÖ Encryption keys –æ–±–Ω–æ–≤–ª–µ–Ω—ã"
}

# –§—É–Ω–∫—Ü–∏—è audit access logs
audit_access_logs() {
    log "üìä Audit access logs"
    
    local audit_report="/tmp/backup-access-audit-$INCIDENT_ID.json"
    
    # –ê–Ω–∞–ª–∏–∑ Kubernetes audit logs
    local suspicious_access=$(kubectl get events --all-namespaces \
        --field-selector type=Warning | \
        grep -E "(backup|velero)" | \
        grep "$(date +%Y-%m-%d)" | wc -l)
    
    # –ê–Ω–∞–ª–∏–∑ Velero logs
    local velero_errors=$(kubectl logs -n velero deployment/velero --since=24h | \
        grep -i "error\|denied\|unauthorized" | wc -l)
    
    # –°–æ–∑–¥–∞–Ω–∏–µ audit report
    cat > $audit_report << AUDIT_REPORT_EOF
{
  "incident_id": "$INCIDENT_ID",
  "audit_timestamp": "$(date -Iseconds)",
  "access_audit": {
    "suspicious_kubernetes_events": $suspicious_access,
    "velero_errors": $velero_errors,
    "recent_backup_operations": $(velero backup get -o json | jq --arg since "$(date -d '24 hours ago' -u +%Y-%m-%dT%H:%M:%SZ)" '[.items[] | select(.metadata.creationTimestamp > $since)] | length'),
    "recent_restore_operations": $(velero restore get -o json | jq --arg since "$(date -d '24 hours ago' -u +%Y-%m-%dT%H:%M:%SZ)" '[.items[] | select(.metadata.creationTimestamp > $since)] | length')
  },
  "rbac_analysis": {
    "backup_role_bindings": $(kubectl get clusterrolebindings -o json | jq '[.items[] | select(.roleRef.name | contains("backup")) | {name: .metadata.name, subjects: .subjects}]'),
    "velero_service_accounts": $(kubectl get serviceaccounts -n velero -o json | jq '[.items[] | {name: .metadata.name, secrets: .secrets}]')
  }
}
AUDIT_REPORT_EOF
    
    log "üìÑ Access audit report: $audit_report"
}

# –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è breach report
create_breach_report() {
    local breach_type=$1
    
    log "üìã –°–æ–∑–¥–∞–Ω–∏–µ breach report"
    
    local breach_report="/tmp/backup-breach-report-$INCIDENT_ID.json"
    
    cat > $breach_report << BREACH_REPORT_EOF
{
  "incident_id": "$INCIDENT_ID",
  "breach_type": "$breach_type",
  "detection_timestamp": "$(date -Iseconds)",
  "affected_systems": {
    "backup_storage_locations": $(kubectl get backupstoragelocations -n velero -o json | jq '[.items[] | {name: .metadata.name, provider: .spec.provider}]'),
    "backup_count": $(velero backup get -o json | jq '.items | length'),
    "encrypted_backups": $(velero backup get -o json | jq '[.items[] | select((.metadata.labels.encrypted // "false") == "true")] | length')
  },
  "response_actions": [
    "Isolated backup system",
    "Rotated all credentials",
    "Created forensic snapshots",
    "Audited access logs",
    "Notified security team"
  ],
  "compliance_notifications": {
    "gdpr_notification_required": true,
    "sox_notification_required": true,
    "notification_deadline": "$(date -d '+72 hours' -u +%Y-%m-%dT%H:%M:%SZ)"
  }
}
BREACH_REPORT_EOF
    
    log "üìÑ Breach report —Å–æ–∑–¥–∞–Ω: $breach_report"
}

# –§—É–Ω–∫—Ü–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è security team
notify_security_team() {
    local incident_type=$1
    local details=$2
    
    log "üìß –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ security team: $incident_type"
    
    # –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ Slack
    if [ -n "$SLACK_SECURITY_WEBHOOK" ]; then
        curl -X POST -H 'Content-type: application/json' \
            --data "{
                \"text\":\"üö® BACKUP SECURITY INCIDENT\",
                \"attachments\":[{
                    \"color\":\"danger\",
                    \"fields\":[{
                        \"title\":\"Incident ID\",
                        \"value\":\"$INCIDENT_ID\",
                        \"short\":true
                    },{
                        \"title\":\"Type\",
                        \"value\":\"$incident_type\",
                        \"short\":true
                    },{
                        \"title\":\"Details\",
                        \"value\":\"$details\",
                        \"short\":false
                    },{
                        \"title\":\"Response Status\",
                        \"value\":\"Automated response activated\",
                        \"short\":true
                    }]
                }]
            }" \
            "$SLACK_SECURITY_WEBHOOK"
    fi
    
    # –°–æ–∑–¥–∞–Ω–∏–µ PagerDuty incident
    if [ -n "$PAGERDUTY_API_KEY" ]; then
        curl -X POST \
            -H "Authorization: Token token=$PAGERDUTY_API_KEY" \
            -H "Content-Type: application/json" \
            -d "{
                \"incident\": {
                    \"type\": \"incident\",
                    \"title\": \"Backup Security Incident: $incident_type\",
                    \"service\": {
                        \"id\": \"$PAGERDUTY_SERVICE_ID\",
                        \"type\": \"service_reference\"
                    },
                    \"urgency\": \"high\",
                    \"body\": {
                        \"type\": \"incident_body\",
                        \"details\": \"Incident ID: $INCIDENT_ID\\nType: $incident_type\\nDetails: $details\"
                    }
                }
            }" \
            "https://api.pagerduty.com/incidents"
    fi
}

# –§—É–Ω–∫—Ü–∏—è recovery –ø–æ—Å–ª–µ incident
post_incident_recovery() {
    log "üîÑ Post-incident recovery"
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ backup –ø–æ—Å–ª–µ incident
    log "üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ backup"
    
    local integrity_issues=0
    
    velero backup get -o json | jq -r '.items[].metadata.name' | \
        while read backup_name; do
            log "–ü—Ä–æ–≤–µ—Ä–∫–∞: $backup_name"
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ backup status
            local backup_status=$(velero backup describe $backup_name | grep "Phase:" | awk '{print $2}')
            
            if [ "$backup_status" != "Completed" ]; then
                log "‚ö†Ô∏è Backup integrity issue: $backup_name ($backup_status)"
                integrity_issues=$((integrity_issues + 1))
            fi
        done
    
    # –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ backup –æ–ø–µ—Ä–∞—Ü–∏–π
    log "üîÑ –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ backup –æ–ø–µ—Ä–∞—Ü–∏–π"
    
    # –£–¥–∞–ª–µ–Ω–∏–µ emergency isolation
    kubectl delete networkpolicy backup-emergency-isolation -n velero --ignore-not-found=true
    
    # –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ Velero deployment
    kubectl patch deployment velero -n velero -p '{"spec":{"replicas":1}}'
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
    kubectl wait --for=condition=available deployment/velero -n velero --timeout=300s
    
    if [ $? -eq 0 ]; then
        log "‚úÖ Backup —Å–∏—Å—Ç–µ–º–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞"
    else
        log "‚ùå –û—à–∏–±–∫–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è backup —Å–∏—Å—Ç–µ–º—ã"
    fi
    
    # –°–æ–∑–¥–∞–Ω–∏–µ post-incident report
    create_post_incident_report
}

# –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è post-incident report
create_post_incident_report() {
    log "üìã –°–æ–∑–¥–∞–Ω–∏–µ post-incident report"
    
    local post_incident_report="/tmp/backup-post-incident-$INCIDENT_ID.json"
    
    cat > $post_incident_report << POST_INCIDENT_EOF
{
  "incident_id": "$INCIDENT_ID",
  "recovery_timestamp": "$(date -Iseconds)",
  "recovery_status": {
    "backup_system_operational": $(kubectl get deployment velero -n velero -o json | jq '.status.readyReplicas > 0'),
    "backup_count_post_incident": $(velero backup get -o json | jq '.items | length'),
    "storage_locations_available": $(kubectl get backupstoragelocations -n velero -o json | jq '[.items[] | select(.status.phase == "Available")] | length')
  },
  "lessons_learned": [
    "Review incident response procedures",
    "Update security monitoring thresholds",
    "Enhance backup encryption policies",
    "Improve access control mechanisms"
  ],
  "action_items": [
    "Conduct security training for operations team",
    "Review and update backup security policies",
    "Implement additional monitoring controls",
    "Schedule regular security assessments"
  ]
}
POST_INCIDENT_EOF
    
    log "üìÑ Post-incident report: $post_incident_report"
}

# –û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
main() {
    case "$1" in
        ransomware)
            ransomware_incident_response
            ;;
        data-breach)
            data_breach_incident_response "$2"
            ;;
        recovery)
            post_incident_recovery
            ;;
        *)
            echo "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: $0 {ransomware|data-breach <type>|recovery}"
            echo "  ransomware    - Ransomware incident response"
            echo "  data-breach   - Data breach incident response"
            echo "  recovery      - Post-incident recovery"
            exit 1
            ;;
    esac
}

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
trap 'log "‚ùå –û—à–∏–±–∫–∞ –≤ incident response"; exit 1' ERR

# –ó–∞–ø—É—Å–∫ –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏
main "$@"
EOF

chmod +x backup-incident-response.sh
```

## üìä **–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ backup security:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 Backup Security Architecture               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Security Layers & Protection Mechanisms                   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ Encryption  ‚îÇ Access      ‚îÇ Network     ‚îÇ Threat      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ At Rest ‚îÇ ‚îú‚îÄ‚îÄ RBAC    ‚îÇ ‚îú‚îÄ‚îÄ VPN     ‚îÇ ‚îú‚îÄ‚îÄ Anti-   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ Transit ‚îÇ ‚îú‚îÄ‚îÄ MFA     ‚îÇ ‚îú‚îÄ‚îÄ Private ‚îÇ ‚îÇ   Ransom  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ Keys    ‚îÇ ‚îú‚îÄ‚îÄ PAM     ‚îÇ ‚îú‚îÄ‚îÄ Firewall‚îÇ ‚îú‚îÄ‚îÄ Malware ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ ‚îî‚îÄ‚îÄ Rotation‚îÇ ‚îî‚îÄ‚îÄ Audit   ‚îÇ ‚îî‚îÄ‚îÄ Isolation‚îÇ ‚îî‚îÄ‚îÄ Anomaly ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Compliance & Governance                                   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ GDPR (Data Protection & Privacy)                   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ SOX (Financial Data Retention)                     ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ HIPAA (Healthcare Data Security)                   ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ PCI-DSS (Payment Card Data)                        ‚îÇ ‚îÇ
‚îÇ  ‚îÇ ‚îî‚îÄ‚îÄ Audit Trails & Incident Response                   ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üéØ **Best Practices –¥–ª—è backup security:**

### **1. Defense in Depth**
- –ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–∞—è –∑–∞—â–∏—Ç–∞ –Ω–∞ –≤—Å–µ—Ö —ç—Ç–∞–ø–∞—Ö backup lifecycle
- Encryption at rest –∏ in transit –¥–ª—è –≤—Å–µ—Ö backup –¥–∞–Ω–Ω—ã—Ö
- Immutable storage –¥–ª—è –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö backup
- Air-gapped copies –¥–ª—è disaster recovery

### **2. Zero Trust Security**
- –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–æ–≤ –∫ backup —Å–∏—Å—Ç–µ–º–µ
- Least privilege access –¥–ª—è backup –æ–ø–µ—Ä–∞—Ü–∏–π
- Continuous monitoring –∏ anomaly detection
- Regular security assessments –∏ penetration testing

### **3. Incident Response**
- Automated threat detection –∏ response
- Forensic capabilities –¥–ª—è investigation
- Rapid isolation –∏ containment procedures
- Post-incident analysis –∏ improvement

### **4. Compliance Management**
- Automated compliance monitoring
- Regular audit trails –∏ reporting
- Data retention policy enforcement
- Regulatory notification procedures

**Comprehensive backup security –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω–∞ –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —É–≥—Ä–æ–∑, –≤–∫–ª—é—á–∞—è ransomware, data breaches –∏ insider threats!**
