# 198. –ß—Ç–æ —Ç–∞–∫–æ–µ Device Plugins –∏ –∫–∞–∫ –æ–Ω–∏ —Ä–∞–±–æ—Ç–∞—é—Ç?

## üéØ **–ß—Ç–æ —Ç–∞–∫–æ–µ Device Plugins?**

**Device Plugins** ‚Äî —ç—Ç–æ –º–µ—Ö–∞–Ω–∏–∑–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è Kubernetes, –ø–æ–∑–≤–æ–ª—è—é—â–∏–π –ø–æ–¥–∞–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∞–ø–ø–∞—Ä–∞—Ç–Ω—ã–µ —Ä–µ—Å—É—Ä—Å—ã (GPU, FPGA, InfiniBand, —Å–µ—Ç–µ–≤—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞) –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –∫–æ–¥–∞ Kubernetes. –û–Ω–∏ —Ä–∞–±–æ—Ç–∞—é—Ç —á–µ—Ä–µ–∑ gRPC API –∏ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É—é—Ç —Å–≤–æ–∏ —Ä–µ—Å—É—Ä—Å—ã –≤ kubelet.

## üèóÔ∏è **–û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã:**

### **1. Device Plugin API**
- gRPC –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å kubelet
- Registration Service –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –ø–ª–∞–≥–∏–Ω–æ–≤
- Device Service –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∂–∏–∑–Ω–µ–Ω–Ω—ã–º —Ü–∏–∫–ª–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤
- Health monitoring –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—è —Å–æ—Å—Ç–æ—è–Ω–∏—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤

### **2. Kubelet Integration**
- Device Manager –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–π –ø–ª–∞–≥–∏–Ω–æ–≤
- Resource Manager –¥–ª—è —Ä–µ–∫–ª–∞–º–∏—Ä–æ–≤–∞–Ω–∏—è —Ä–µ—Å—É—Ä—Å–æ–≤ –≤ API server
- Pod Manager –¥–ª—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ container runtime
- Automatic device discovery –∏ allocation

### **3. Hardware Abstraction**
- –°—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –ª—é–±—ã—Ö —Ç–∏–ø–æ–≤ —É—Å—Ç—Ä–æ–π—Å—Ç–≤
- –ü–æ–¥–¥–µ—Ä–∂–∫–∞ NUMA topology awareness
- –ò–∑–æ–ª—è—Ü–∏—è —Ä–µ—Å—É—Ä—Å–æ–≤ –º–µ–∂–¥—É –ø–æ–¥–∞–º–∏
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ device files –∏ mounts

## üìä **–ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–µ—Ä—ã –∏–∑ –≤–∞—à–µ–≥–æ HA –∫–ª–∞—Å—Ç–µ—Ä–∞:**

### **1. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö Device Plugins:**
```bash
# –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö extended resources –Ω–∞ —É–∑–ª–∞—Ö
kubectl get nodes -o json | jq '.items[].status.allocatable' | grep -E "(nvidia|intel|amd)"

# –ü—Ä–æ–≤–µ—Ä–∫–∞ capacity –∏ allocatable —Ä–µ—Å—É—Ä—Å–æ–≤
kubectl describe nodes | grep -A 10 "Capacity\|Allocatable"

# –ü—Ä–æ–≤–µ—Ä–∫–∞ device plugin sockets –Ω–∞ —É–∑–ª–∞—Ö
kubectl debug node/<node-name> -it --image=busybox -- ls -la /host/var/lib/kubelet/device-plugins/

# –ü—Ä–æ–≤–µ—Ä–∫–∞ device plugin pods –≤ –∫–ª–∞—Å—Ç–µ—Ä–µ
kubectl get pods --all-namespaces | grep -E "(device|gpu|fpga)"

# –ü—Ä–æ–≤–µ—Ä–∫–∞ extended resources –≤ node status
kubectl get nodes -o yaml | grep -A 5 -B 5 "nvidia.com\|intel.com\|amd.com"
```

### **2. –ê–Ω–∞–ª–∏–∑ GPU resources (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω—ã):**
```bash
# –ü—Ä–æ–≤–µ—Ä–∫–∞ NVIDIA GPU resources
kubectl get nodes -o json | jq '.items[] | {name: .metadata.name, gpu: .status.allocatable["nvidia.com/gpu"]}'

# –ü—Ä–æ–≤–µ—Ä–∫–∞ GPU pods
kubectl get pods --all-namespaces -o json | jq '.items[] | select(.spec.containers[].resources.limits["nvidia.com/gpu"]) | {name: .metadata.name, namespace: .metadata.namespace}'

# –ü—Ä–æ–≤–µ—Ä–∫–∞ GPU utilization
kubectl top nodes --show-capacity

# –ü—Ä–æ–≤–µ—Ä–∫–∞ device plugin logs
kubectl logs -n kube-system -l app=nvidia-device-plugin --tail=20
```

### **3. –°–æ–∑–¥–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ Device Plugin:**
```bash
# –°–æ–∑–¥–∞–Ω–∏–µ namespace –¥–ª—è device plugin
kubectl create namespace device-plugin-system

# –°–æ–∑–¥–∞–Ω–∏–µ ConfigMap —Å device plugin –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–µ–π
kubectl create configmap device-plugin-config -n device-plugin-system \
  --from-literal=device-count=4 \
  --from-literal=device-prefix=hashfoundry-device

# –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–∑–¥–∞–Ω–Ω—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤
kubectl get configmap -n device-plugin-system
kubectl describe configmap device-plugin-config -n device-plugin-system
```

### **4. –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ Device Plugin –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:**
```bash
# –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —á–µ—Ä–µ–∑ Prometheus
kubectl port-forward svc/prometheus-server -n monitoring 9090:80 &

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–µ—Ç—Ä–∏–∫ device plugins
# Query: kubelet_device_plugin_registration_total
# Query: kubelet_device_plugin_alloc_duration_seconds

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–æ–≥–æ–≤ kubelet –¥–ª—è device plugins
kubectl logs -n kube-system -l component=kubelet | grep -i "device\|plugin"

# –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —á–µ—Ä–µ–∑ Grafana
kubectl port-forward svc/grafana -n monitoring 3000:80 &
```

## üîÑ **–†–µ–∞–ª–∏–∑–∞—Ü–∏—è Custom Device Plugin:**

### **1. Device Plugin Server Implementation:**
```yaml
# custom-device-plugin.yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: custom-device-plugin
  namespace: device-plugin-system
  labels:
    app: custom-device-plugin
spec:
  selector:
    matchLabels:
      app: custom-device-plugin
  template:
    metadata:
      labels:
        app: custom-device-plugin
    spec:
      serviceAccountName: device-plugin-service-account
      hostNetwork: true
      hostPID: true
      tolerations:
      - key: node-role.kubernetes.io/control-plane
        operator: Exists
        effect: NoSchedule
      - key: node-role.kubernetes.io/master
        operator: Exists
        effect: NoSchedule
      containers:
      - name: device-plugin
        image: hashfoundry/custom-device-plugin:v1.0.0
        command: ["/usr/bin/custom-device-plugin"]
        args:
        - --resource-name=hashfoundry.com/custom-device
        - --device-count=4
        - --health-check-interval=30s
        - --log-level=info
        env:
        - name: NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        - name: DEVICE_PLUGIN_PATH
          value: "/var/lib/kubelet/device-plugins"
        securityContext:
          privileged: true
          capabilities:
            add:
            - SYS_ADMIN
        volumeMounts:
        - name: device-plugin
          mountPath: /var/lib/kubelet/device-plugins
        - name: dev
          mountPath: /dev
        - name: sys
          mountPath: /sys
        - name: proc
          mountPath: /proc
        resources:
          requests:
            cpu: 50m
            memory: 64Mi
          limits:
            cpu: 200m
            memory: 256Mi
        livenessProbe:
          httpGet:
            path: /healthz
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /readyz
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 10
      volumes:
      - name: device-plugin
        hostPath:
          path: /var/lib/kubelet/device-plugins
      - name: dev
        hostPath:
          path: /dev
      - name: sys
        hostPath:
          path: /sys
      - name: proc
        hostPath:
          path: /proc
      nodeSelector:
        hashfoundry.com/custom-device: "enabled"

---
# Service –¥–ª—è health checks
apiVersion: v1
kind: Service
metadata:
  name: custom-device-plugin
  namespace: device-plugin-system
  labels:
    app: custom-device-plugin
spec:
  selector:
    app: custom-device-plugin
  ports:
  - name: health
    port: 8080
    targetPort: 8080
    protocol: TCP
  type: ClusterIP

---
# ServiceAccount –∏ RBAC
apiVersion: v1
kind: ServiceAccount
metadata:
  name: device-plugin-service-account
  namespace: device-plugin-system

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: device-plugin-reader
rules:
- apiGroups: [""]
  resources: ["nodes"]
  verbs: ["get", "list", "watch", "patch"]
- apiGroups: [""]
  resources: ["events"]
  verbs: ["create", "patch"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: device-plugin-reader-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: device-plugin-reader
subjects:
- kind: ServiceAccount
  name: device-plugin-service-account
  namespace: device-plugin-system
```

### **2. Device Plugin Go Implementation:**
```go
// main.go
package main

import (
    "context"
    "fmt"
    "net"
    "net/http"
    "os"
    "path/filepath"
    "strings"
    "time"

    "google.golang.org/grpc"
    "k8s.io/klog/v2"
    pluginapi "k8s.io/kubelet/pkg/apis/deviceplugin/v1beta1"
)

const (
    defaultResourceName = "hashfoundry.com/custom-device"
    defaultDeviceCount  = 4
    kubeletSocket      = pluginapi.KubeletSocket
    devicePluginPath   = pluginapi.DevicePluginPath
)

type CustomDevicePlugin struct {
    resourceName string
    socket       string
    server       *grpc.Server
    devices      map[string]*pluginapi.Device
    stop         chan interface{}
    health       chan *pluginapi.Device
    deviceCount  int
}

func NewCustomDevicePlugin(resourceName string, deviceCount int) *CustomDevicePlugin {
    serverSock := filepath.Join(devicePluginPath, 
        strings.Replace(resourceName, "/", "-", -1)+".sock")
    
    return &CustomDevicePlugin{
        resourceName: resourceName,
        socket:       serverSock,
        devices:      make(map[string]*pluginapi.Device),
        stop:         make(chan interface{}),
        health:       make(chan *pluginapi.Device),
        deviceCount:  deviceCount,
    }
}

func main() {
    klog.Info("Starting HashFoundry Custom Device Plugin")
    
    // Parse command line arguments
    resourceName := getEnvOrDefault("RESOURCE_NAME", defaultResourceName)
    deviceCount := getIntEnvOrDefault("DEVICE_COUNT", defaultDeviceCount)
    
    plugin := NewCustomDevicePlugin(resourceName, deviceCount)
    
    // Start health check server
    go plugin.startHealthServer()
    
    // Discover devices
    if err := plugin.discoverDevices(); err != nil {
        klog.Fatalf("Failed to discover devices: %v", err)
    }
    
    // Start device plugin server
    if err := plugin.Start(); err != nil {
        klog.Fatalf("Failed to start device plugin: %v", err)
    }
    
    // Register with kubelet
    if err := plugin.Register(); err != nil {
        klog.Fatalf("Failed to register device plugin: %v", err)
    }
    
    klog.Info("Device plugin started successfully")
    
    // Start health monitoring
    go plugin.healthMonitor()
    
    // Wait for termination signal
    <-plugin.stop
    
    klog.Info("Shutting down device plugin")
    plugin.Stop()
}

func (dp *CustomDevicePlugin) Start() error {
    if err := dp.cleanup(); err != nil {
        return err
    }
    
    sock, err := net.Listen("unix", dp.socket)
    if err != nil {
        return fmt.Errorf("failed to listen on socket %s: %v", dp.socket, err)
    }
    
    dp.server = grpc.NewServer()
    pluginapi.RegisterDevicePluginServer(dp.server, dp)
    
    go func() {
        if err := dp.server.Serve(sock); err != nil {
            klog.Errorf("Failed to serve: %v", err)
        }
    }()
    
    // Wait for server to start
    conn, err := grpc.Dial(dp.socket, grpc.WithInsecure(), grpc.WithBlock(),
        grpc.WithTimeout(5*time.Second),
        grpc.WithDialer(func(addr string, timeout time.Duration) (net.Conn, error) {
            return net.DialTimeout("unix", addr, timeout)
        }))
    if err != nil {
        return fmt.Errorf("failed to connect to device plugin server: %v", err)
    }
    conn.Close()
    
    klog.Info("Device plugin server started")
    return nil
}

func (dp *CustomDevicePlugin) Register() error {
    conn, err := grpc.Dial(kubeletSocket, grpc.WithInsecure(),
        grpc.WithDialer(func(addr string, timeout time.Duration) (net.Conn, error) {
            return net.DialTimeout("unix", addr, timeout)
        }))
    if err != nil {
        return fmt.Errorf("failed to connect to kubelet: %v", err)
    }
    defer conn.Close()
    
    client := pluginapi.NewRegistrationClient(conn)
    
    request := &pluginapi.RegisterRequest{
        Version:      pluginapi.Version,
        Endpoint:     filepath.Base(dp.socket),
        ResourceName: dp.resourceName,
        Options: &pluginapi.DevicePluginOptions{
            PreStartRequired:                false,
            GetPreferredAllocationAvailable: true,
        },
    }
    
    if _, err := client.Register(context.Background(), request); err != nil {
        return fmt.Errorf("failed to register device plugin: %v", err)
    }
    
    klog.Infof("Device plugin registered with kubelet for resource: %s", dp.resourceName)
    return nil
}

func (dp *CustomDevicePlugin) GetDevicePluginOptions(context.Context, *pluginapi.Empty) (*pluginapi.DevicePluginOptions, error) {
    return &pluginapi.DevicePluginOptions{
        PreStartRequired:                false,
        GetPreferredAllocationAvailable: true,
    }, nil
}

func (dp *CustomDevicePlugin) ListAndWatch(e *pluginapi.Empty, s pluginapi.DevicePlugin_ListAndWatchServer) error {
    klog.Info("Starting ListAndWatch")
    
    if err := s.Send(&pluginapi.ListAndWatchResponse{Devices: dp.getDevices()}); err != nil {
        return fmt.Errorf("failed to send device list: %v", err)
    }
    
    for {
        select {
        case <-dp.stop:
            return nil
        case device := <-dp.health:
            if dev, exists := dp.devices[device.ID]; exists {
                dev.Health = device.Health
                klog.Infof("Device %s health changed to %s", device.ID, device.Health)
                if err := s.Send(&pluginapi.ListAndWatchResponse{Devices: dp.getDevices()}); err != nil {
                    return fmt.Errorf("failed to send device update: %v", err)
                }
            }
        }
    }
}

func (dp *CustomDevicePlugin) Allocate(ctx context.Context, reqs *pluginapi.AllocateRequest) (*pluginapi.AllocateResponse, error) {
    klog.Infof("Allocate request: %v", reqs)
    
    responses := &pluginapi.AllocateResponse{}
    
    for _, req := range reqs.ContainerRequests {
        response := &pluginapi.ContainerAllocateResponse{}
        
        for _, deviceID := range req.DevicesIDs {
            device, exists := dp.devices[deviceID]
            if !exists {
                return nil, fmt.Errorf("device %s not found", deviceID)
            }
            
            if device.Health != pluginapi.Healthy {
                return nil, fmt.Errorf("device %s is not healthy", deviceID)
            }
            
            // Set environment variables
            if response.Envs == nil {
                response.Envs = make(map[string]string)
            }
            response.Envs["HASHFOUNDRY_DEVICE_ID"] = deviceID
            response.Envs["HASHFOUNDRY_DEVICE_PATH"] = fmt.Sprintf("/dev/hashfoundry-device-%s", deviceID)
            response.Envs["HASHFOUNDRY_DEVICE_COUNT"] = fmt.Sprintf("%d", len(req.DevicesIDs))
            
            // Add device mounts
            devicePath := fmt.Sprintf("/dev/hashfoundry-device-%s", deviceID)
            response.Mounts = append(response.Mounts, &pluginapi.Mount{
                ContainerPath: devicePath,
                HostPath:      devicePath,
                ReadOnly:      false,
            })
            
            // Add device specifications
            response.Devices = append(response.Devices, &pluginapi.DeviceSpec{
                ContainerPath: devicePath,
                HostPath:      devicePath,
                Permissions:   "rw",
            })
            
            // Add annotations for monitoring
            if response.Annotations == nil {
                response.Annotations = make(map[string]string)
            }
            response.Annotations["hashfoundry.com/device-allocated"] = deviceID
            response.Annotations["hashfoundry.com/allocation-time"] = time.Now().Format(time.RFC3339)
            
            klog.Infof("Allocated device %s to container", deviceID)
        }
        
        responses.ContainerResponses = append(responses.ContainerResponses, response)
    }
    
    return responses, nil
}

func (dp *CustomDevicePlugin) GetPreferredAllocation(ctx context.Context, req *pluginapi.PreferredAllocationRequest) (*pluginapi.PreferredAllocationResponse, error) {
    response := &pluginapi.PreferredAllocationResponse{}
    
    for _, containerReq := range req.ContainerRequests {
        containerResp := &pluginapi.ContainerPreferredAllocationResponse{}
        
        // Simple allocation strategy: prefer devices with lower IDs
        availableDevices := containerReq.AvailableDeviceIDs
        mustIncludeDevices := containerReq.MustIncludeDeviceIDs
        allocationSize := int(containerReq.AllocationSize)
        
        // Start with must-include devices
        preferredDevices := make([]string, 0, allocationSize)
        preferredDevices = append(preferredDevices, mustIncludeDevices...)
        
        // Add additional devices if needed
        for _, deviceID := range availableDevices {
            if len(preferredDevices) >= allocationSize {
                break
            }
            
            // Skip if already included
            found := false
            for _, included := range preferredDevices {
                if included == deviceID {
                    found = true
                    break
                }
            }
            
            if !found {
                preferredDevices = append(preferredDevices, deviceID)
            }
        }
        
        containerResp.DeviceIDs = preferredDevices
        response.ContainerResponses = append(response.ContainerResponses, containerResp)
        
        klog.Infof("Preferred allocation for container: %v", preferredDevices)
    }
    
    return response, nil
}

func (dp *CustomDevicePlugin) PreStartContainer(context.Context, *pluginapi.PreStartContainerRequest) (*pluginapi.PreStartContainerResponse, error) {
    return &pluginapi.PreStartContainerResponse{}, nil
}

func (dp *CustomDevicePlugin) discoverDevices() error {
    klog.Infof("Discovering %d devices", dp.deviceCount)
    
    for i := 0; i < dp.deviceCount; i++ {
        deviceID := fmt.Sprintf("device-%d", i)
        device := &pluginapi.Device{
            ID:     deviceID,
            Health: pluginapi.Healthy,
            Topology: &pluginapi.TopologyInfo{
                Nodes: []*pluginapi.NUMANode{
                    {
                        ID: int64(i % 2), // Distribute across NUMA nodes
                    },
                },
            },
        }
        dp.devices[deviceID] = device
        
        // Create device file (simulation)
        devicePath := fmt.Sprintf("/dev/hashfoundry-device-%s", deviceID)
        if err := dp.createDeviceFile(devicePath); err != nil {
            klog.Warningf("Failed to create device file %s: %v", devicePath, err)
        }
        
        klog.Infof("Discovered device: %s", deviceID)
    }
    
    return nil
}

func (dp *CustomDevicePlugin) createDeviceFile(devicePath string) error {
    // Create device file for simulation
    file, err := os.Create(devicePath)
    if err != nil {
        return err
    }
    defer file.Close()
    
    // Write device metadata
    metadata := fmt.Sprintf("HashFoundry Custom Device\nCreated: %s\n", time.Now().Format(time.RFC3339))
    _, err = file.WriteString(metadata)
    return err
}

func (dp *CustomDevicePlugin) getDevices() []*pluginapi.Device {
    devices := make([]*pluginapi.Device, 0, len(dp.devices))
    for _, device := range dp.devices {
        devices = append(devices, device)
    }
    return devices
}

func (dp *CustomDevicePlugin) healthMonitor() {
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-dp.stop:
            return
        case <-ticker.C:
            dp.checkDeviceHealth()
        }
    }
}

func (dp *CustomDevicePlugin) checkDeviceHealth() {
    for deviceID, device := range dp.devices {
        healthy := dp.isDeviceHealthy(deviceID)
        
        if healthy && device.Health != pluginapi.Healthy {
            device.Health = pluginapi.Healthy
            dp.health <- device
        } else if !healthy && device.Health != pluginapi.Unhealthy {
            device.Health = pluginapi.Unhealthy
            dp.health <- device
        }
    }
}

func (dp *CustomDevicePlugin) isDeviceHealthy(deviceID string) bool {
    devicePath := fmt.Sprintf("/dev/hashfoundry-device-%s", deviceID)
    if _, err := os.Stat(devicePath); err != nil {
        return false
    }
    
    // Additional health checks can be added here
    // For example: check device responsiveness, temperature, etc.
    
    return true
}

func (dp *CustomDevicePlugin) startHealthServer() {
    http.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("OK"))
    })
    
    http.HandleFunc("/readyz", func(w http.ResponseWriter, r *http.Request) {
        if len(dp.devices) > 0 {
            w.WriteHeader(http.StatusOK)
            w.Write([]byte("Ready"))
        } else {
            w.WriteHeader(http.StatusServiceUnavailable)
            w.Write([]byte("Not Ready"))
        }
    })
    
    klog.Info("Starting health server on :8080")
    if err := http.ListenAndServe(":8080", nil); err != nil {
        klog.Errorf("Health server failed: %v", err)
    }
}

func (dp *CustomDevicePlugin) cleanup() error {
    if err := os.Remove(dp.socket); err != nil && !os.IsNotExist(err) {
        return fmt.Errorf("failed to remove socket %s: %v", dp.socket, err)
    }
    return nil
}

func (dp *CustomDevicePlugin) Stop() error {
    if dp.server != nil {
        dp.server.Stop()
    }
    close(dp.stop)
    return dp.cleanup()
}

func getEnvOrDefault(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func getIntEnvOrDefault(key string, defaultValue int) int {
    if value := os.Getenv(key); value != "" {
        if intValue, err := strconv.Atoi(value); err == nil {
            return intValue
        }
    }
    return defaultValue
}
```

### **3. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ Device Plugin:**
```yaml
# test-device-usage.yaml
apiVersion: v1
kind: Pod
metadata:
  name: device-test-single
  namespace: device-plugin-system
  labels:
    app: device-test
spec:
  containers:
  - name: test-container
    image: busybox:1.35
    command: ["/bin/sh"]
    args:
    - -c
    - |
      echo "=== HashFoundry Device Test ==="
      echo "Environment variables:"
      env | grep HASHFOUNDRY
      echo ""
      echo "Device files:"
      ls -la /dev/hashfoundry-device-* 2>/dev/null || echo "No device files found"
      echo ""
      echo "Device content:"
      for device in /dev/hashfoundry-device-*; do
        if [ -f "$device" ]; then
          echo "--- $device ---"
          cat "$device"
        fi
      done
      echo ""
      echo "Sleeping for monitoring..."
      sleep 3600
    resources:
      limits:
        hashfoundry.com/custom-device: 1
      requests:
        hashfoundry.com/custom-device: 1
  restartPolicy: Never

---
# Multi-device test
apiVersion: v1
kind: Pod
metadata:
  name: device-test-multi
  namespace: device-plugin-system
  labels:
    app: device-test
spec:
  containers:
  - name: test-container
    image: busybox:1.35
    command: ["/bin/sh"]
    args:
    - -c
    - |
      echo "=== Multi-Device Test ==="
      echo "Allocated devices: $HASHFOUNDRY_DEVICE_COUNT"
      echo "Device ID: $HASHFOUNDRY_DEVICE_ID"
      echo ""
      echo "Available devices:"
      ls -la /dev/hashfoundry-device-*
      echo ""
      echo "Testing device access..."
      for device in /dev/hashfoundry-device-*; do
        if [ -f "$device" ]; then
          echo "Testing $device..."
          cat "$device" | head -2
        fi
      done
      sleep 3600
    resources:
      limits:
        hashfoundry.com/custom-device: 2
      requests:
        hashfoundry.com/custom-device: 2
  restartPolicy: Never

---
# Deployment with device usage
apiVersion: apps/v1
kind: Deployment
metadata:
  name: device-workload
  namespace: device-plugin-system
spec:
  replicas: 2
  selector:
    matchLabels:
      app: device-workload
  template:
    metadata:
      labels:
        app: device-workload
    spec:
      containers:
      - name: workload
        image: nginx:1.21
        resources:
          limits:
            hashfoundry.com/custom-device: 1
          requests:
            hashfoundry.com/custom-device: 1
            cpu: 100m
            memory: 128Mi
        env:
        - name: DEVICE_ID
          value: "$(HASHFOUNDRY_DEVICE_ID)"
        volumeMounts:
        - name: device-info
          mountPath: /usr/share/nginx/html/device
        lifecycle:
          postStart:
            exec:
              command:
              - /bin/sh
              - -c
              - |
                echo "Device allocated: $HASHFOUNDRY_DEVICE_ID" > /usr/share/nginx/html/device/info.txt
                echo "Allocation time: $(date)" >> /usr/share/nginx/html/device/info.txt
      volumes:
      - name: device-info
        emptyDir: {}
```

## üè≠ **–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å ArgoCD –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–º:**

### **1. ArgoCD Application –¥–ª—è Device Plugin:**
```yaml
# argocd-device-plugin-application.yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: custom-device-plugin
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/hashfoundry/custom-device-plugin
    targetRevision: HEAD
    path: k8s
  destination:
    server: https://kubernetes.default.svc
    namespace: device-plugin-system
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
    - CreateNamespace=true
    retry:
      limit: 5
      backoff:
        duration: 5s
        factor: 2
        maxDuration: 3m
```

### **2. Prometheus –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –¥–ª—è Device Plugins:**
```yaml
# device-plugin-monitoring.yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: custom-device-plugin
  namespace: device-plugin-system
spec:
  selector:
    matchLabels:
      app: custom-device-plugin
  endpoints:
  - port: health
    path: /metrics
    interval: 30s

---
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: device-plugin-alerts
  namespace: device-plugin-system
spec:
  groups:
  - name: device-plugin.rules
    rules:
    - alert: DevicePluginDown
      expr: up{job="custom-device-plugin"} == 0
      for: 2m
      labels:
        severity: critical
      annotations:
        summary: "Device plugin is down"
        description: "Custom device plugin has been down for more than 2 minutes"
    
    - alert: DeviceUnhealthy
      expr: kubelet_device_plugin_resource_capacity{resource="hashfoundry.com/custom-device"} != kubelet_device_plugin_resource_allocatable{resource="hashfoundry.com/custom-device"}
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "Unhealthy devices detected"
        description: "Some custom devices are marked as unhealthy"
    
    - alert: DeviceAllocationHigh
      expr: (kubelet_device_plugin_resource_capacity{resource="hashfoundry.com/custom-device"} - kubelet_device_plugin_resource_allocatable{resource="hashfoundry.com/custom-device"}) / kubelet_device_plugin_resource_capacity{resource="hashfoundry.com/custom-device"} > 0.8
      for: 10m
      labels:
        severity: warning
      annotations:
        summary: "High device allocation"
        description: "More than 80% of custom devices are allocated"
```

### **3. Grafana Dashboard –¥–ª—è Device Plugins:**
```json
{
  "dashboard": {
    "title": "HashFoundry Device Plugin Dashboard",
    "panels": [
      {
        "title": "Device Plugin Status",
        "type": "stat",
        "targets": [
          {
            "expr": "up{job=\"custom-device-plugin\"}",
            "legendFormat": "Plugin Status"
          }
        ]
      },
      {
        "title": "Device Capacity vs Allocatable",
        "type": "graph",
        "targets": [
          {
            "expr": "kubelet_device_plugin_resource_capacity{resource=\"hashfoundry.com/custom-device\"}",
            "legendFormat": "Capacity - {{node}}"
          },
          {
            "expr": "kubelet_device_plugin_resource_allocatable{resource=\"hashfoundry.com/custom-device\"}",
            "legendFormat": "Allocatable - {{node}}"
          }
        ]
      },
      {
        "title": "Device Allocation Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(kubelet_device_plugin_alloc_duration_seconds_count[5m])",
            "legendFormat": "Allocations/sec - {{node}}"
          }
        ]
      }
    ]
  }
}
```

### **4. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ Device Plugins:**
```bash
#!/bin/bash
# test-device-plugins.sh

echo "üß™ Testing Device Plugins"

test_device_plugin_registration() {
    echo "=== Testing Device Plugin Registration ==="
    
    # Check device plugin registration
    kubectl get nodes -o json | jq '.items[] | {
        name: .metadata.name,
        capacity: .status.capacity,
        allocatable: .status.allocatable
    }' | grep -A 5 -B 5 "hashfoundry.com/custom-device"
    
    # Check device plugin sockets
    for node in $(kubectl get nodes -o jsonpath='{.items[*].metadata.name}'); do
        echo "--- Node: $node ---"
        kubectl debug node/$node -it --image=busybox -- \
            ls -la /host/var/lib/kubelet/device-plugins/ | grep hashfoundry || \
            echo "No HashFoundry device plugin socket found"
    done
}

test_device_allocation() {
    echo "=== Testing Device Allocation ==="
    
    # Create test pod
    cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: device-allocation-test
  namespace: device-plugin-system
spec:
  containers:
  - name: test
    image: busybox:1.35
    command: ["sleep", "300"]
    resources:
      limits:
        hashfoundry.com/custom-device: 1
      requests:
        hashfoundry.com/custom-device: 1
  restartPolicy: Never
EOF

    # Wait for pod to be scheduled
    kubectl wait --for=condition=Ready pod/device-allocation-test -n device-plugin-system --timeout=60s
    
    # Check device allocation
    kubectl describe pod device-allocation-test -n device-plugin-system | grep -A 10 "Environment\|Mounts"
    
    # Check device files in container
    kubectl exec device-allocation-test -n device-plugin-system -- ls -la /dev/hashfoundry-device-*
    
    # Cleanup
    kubectl delete pod device-allocation-test -n device-plugin-system
}

check_device_plugin_health() {
    echo "=== Device Plugin Health Check ==="
    
    # Check device plugin pods
    kubectl get pods -n device-plugin-system -l app=custom-device-plugin
    
    # Check device plugin logs
    kubectl logs -n device-plugin-system -l app=custom-device-plugin --tail=20
    
    # Check device plugin health endpoint
    kubectl port-forward -n device-plugin-system svc/custom-device-plugin 8080:8080 &
    PF_PID=$!
    
    sleep 2
    curl -f http://localhost:8080/healthz && echo "‚úÖ Health check passed" || echo "‚ùå Health check failed"
    curl -f http://localhost:8080/readyz && echo "‚úÖ Ready check passed" || echo "‚ùå Ready check failed"
    
    kill $PF_PID
}

monitor_device_metrics() {
    echo "=== Device Plugin Metrics ==="
    
    # Port forward to Prometheus
    kubectl port-forward svc/prometheus-server -n monitoring 9090:80 &
    PROM_PID=$!
    
    sleep 2
    
    # Query device plugin metrics
    echo "Device plugin registration count:"
    curl -s "http://localhost:9090/api/v1/query?query=kubelet_device_plugin_registration_total" | \
        jq -r '.data.result[] | "\(.metric.node): \(.value[1])"'
    
    echo ""
    echo "Device allocation duration:"
    curl -s "http://localhost:9090/api/v1/query?query=kubelet_device_plugin_alloc_duration_seconds" | \
        jq -r '.data.result[] | "\(.metric.node): \(.value[1])s"'
    
    kill $PROM_PID
}

main() {
    test_device_plugin_registration
    echo ""
    test_device_allocation
    echo ""
    check_device_plugin_health
    echo ""
    monitor_device_metrics
}

main "$@"
```

## üö® **Troubleshooting Device Plugins:**

### **1. –î–∏–∞–≥–Ω–æ—Å—Ç–∏—á–µ—Å–∫–∏–π —Å–∫—Ä–∏–ø—Ç:**
```bash
#!/bin/bash
# diagnose-device-plugins.sh

echo "üîç Diagnosing Device Plugins"

diagnose_kubelet_device_manager() {
    echo "=== Kubelet Device Manager Diagnosis ==="
    
    # Check kubelet logs for device plugin activity
    for node in $(kubectl get nodes -o jsonpath='{.items[*].metadata.name}'); do
        echo "--- Node: $node ---"
        kubectl debug node/$node -it --image=busybox -- \
            grep -i "device.*plugin\|device.*manager" /host/var/log/kubelet.log | tail -10
    done
}

check_device_plugin_sockets() {
    echo "=== Device Plugin Sockets Check ==="
    
    for node in $(kubectl get nodes -o jsonpath='{.items[*].metadata.name}'); do
        echo "--- Node: $node ---"
        kubectl debug node/$node -it --image=busybox -- \
            find /host/var/lib/kubelet/device-plugins/ -name "*.sock" -ls
    done
}

verify_device_files() {
    echo "=== Device Files Verification ==="
    
    for node in $(kubectl get nodes -o jsonpath='{.items[*].metadata.name}'); do
        echo "--- Node: $node ---"
        kubectl debug node/$node -it --image=busybox -- \
            ls -la /host/dev/hashfoundry-device-* 2>/dev/null || \
            echo "No HashFoundry device files found"
    done
}

check_extended_resources() {
    echo "=== Extended Resources Check ==="
    
    kubectl get nodes -o json | jq '.items[] | {
        name: .metadata.name,
        capacity: .status.capacity | to_entries | map(select(.key | contains("hashfoundry.com"))),
        allocatable: .status.allocatable | to_entries | map(select(.key | contains("hashfoundry.com")))
    }'
}

analyze_pod_allocation_failures() {
    echo "=== Pod Allocation Failures Analysis ==="
    
    # Check for pods with device resource requests that are pending
    kubectl get pods --all-namespaces -o json | jq -r '
        .items[] | 
        select(.status.phase == "Pending") |
        select(.spec.containers[].resources.limits | has("hashfoundry.com/custom-device")) |
        "\(.metadata.namespace)/\(.metadata.name): \(.status.conditions[-1].message // "No message")"
    '
    
    # Check events related to device allocation
    kubectl get events --all-namespaces --field-selector reason=FailedScheduling | \
        grep -i "device\|resource"
}

main() {
    diagnose_kubelet_device_manager
    echo ""
    check_device_plugin_sockets
    echo ""
    verify_device_files
    echo ""
    check_extended_resources
    echo ""
    analyze_pod_allocation_failures
}

main "$@"
```

### **2. Device Plugin Lifecycle Management:**
```bash
#!/bin/bash
# device-plugin-lifecycle.sh

echo "üîÑ Device Plugin Lifecycle Management"

deploy_device_plugin() {
    echo "=== Deploying Device Plugin ==="
    
    # Label nodes for device plugin
    kubectl label nodes --all hashfoundry.com/custom-device=enabled --overwrite
    
    # Deploy device plugin DaemonSet
    kubectl apply -f custom-device-plugin.yaml
    
    # Wait for device plugin to be ready
    kubectl rollout status daemonset/custom-device-plugin -n device-plugin-system --timeout=300s
    
    # Verify device plugin registration
    sleep 10
    kubectl get nodes -o json | jq '.items[0].status.allocatable' | grep hashfoundry.com
}

update_device_plugin() {
    echo "=== Updating Device Plugin ==="
    
    # Update device plugin image
    kubectl set image daemonset/custom-device-plugin -n device-plugin-system \
        device-plugin=hashfoundry/custom-device-plugin:v1.1.0
    
    # Monitor rollout
    kubectl rollout status daemonset/custom-device-plugin -n device-plugin-system
    
    # Verify update
    kubectl get pods -n device-plugin-system -l app=custom-device-plugin \
        -o jsonpath='{.items[*].spec.containers[0].image}'
}

restart_device_plugin() {
    echo "=== Restarting Device Plugin ==="
    
    # Restart device plugin pods
    kubectl rollout restart daemonset/custom-device-plugin -n device-plugin-system
    
    # Wait for restart to complete
    kubectl rollout status daemonset/custom-device-plugin -n device-plugin-system
    
    # Verify device resources are still available
    kubectl get nodes -o json | jq '.items[].status.allocatable' | grep hashfoundry.com
}

cleanup_device_plugin() {
    echo "=== Cleaning up Device Plugin ==="
    
    # Delete device plugin DaemonSet
    kubectl delete daemonset custom-device-plugin -n device-plugin-system
    
    # Remove node labels
    kubectl label nodes --all hashfoundry.com/custom-device-
    
    # Clean up device files on nodes
    for node in $(kubectl get nodes -o jsonpath='{.items[*].metadata.name}'); do
        kubectl debug node/$node -it --image=busybox -- \
            rm -f /host/dev/hashfoundry-device-*
    done
    
    # Verify cleanup
    kubectl get nodes -o json | jq '.items[].status.allocatable' | grep hashfoundry.com || \
        echo "‚úÖ Device resources cleaned up successfully"
}

main() {
    case "${1:-deploy}" in
        deploy)
            deploy_device_plugin
            ;;
        update)
            update_device_plugin
            ;;
        restart)
            restart_device_plugin
            ;;
        cleanup)
            cleanup_device_plugin
            ;;
        *)
            echo "Usage: $0 {deploy|update|restart|cleanup}"
            exit 1
            ;;
    esac
}

main "$@"
```

## üéØ **–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ Device Plugins –≤ HA –∫–ª–∞—Å—Ç–µ—Ä–µ:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              HA Cluster Device Plugins Architecture        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Application Pods                                          ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ ML Workloads (GPU requests)                           ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Network Functions (SR-IOV)                            ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Storage Accelerators (NVMe)                           ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Custom Hardware (HashFoundry devices)                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Kubernetes API Server (HA)                               ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Extended Resource Advertisement                       ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Pod Scheduling with Device Constraints                ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Resource Quota Management                             ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ RBAC for Device Access                                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Worker Nodes (Auto-scaling 3-6 nodes)                    ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Node 1                                                ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ kubelet (Device Manager)                          ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ Device Plugin DaemonSet                           ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ Container Runtime (device mounting)               ‚îÇ
‚îÇ  ‚îÇ   ‚îî‚îÄ‚îÄ Hardware Devices (/dev/*)                         ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Node 2                                                ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ kubelet (Device Manager)                          ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ Device Plugin DaemonSet                           ‚îÇ
‚îÇ  ‚îÇ   ‚îú‚îÄ‚îÄ Container Runtime (device mounting)               ‚îÇ
‚îÇ  ‚îÇ   ‚îî‚îÄ‚îÄ Hardware Devices (/dev/*)                         ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Node N...                                             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Device Plugin Communication                               ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ gRPC Registration (plugin ‚Üí kubelet)                  ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Unix Socket (/var/lib/kubelet/device-plugins/)        ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ ListAndWatch Stream (device health)                   ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Allocate Requests (device assignment)                 ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Health Monitoring (device status)                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Monitoring & Observability                               ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Prometheus (device plugin metrics)                    ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Grafana (device utilization dashboards)              ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ AlertManager (device failure alerts)                  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Logs (device plugin + kubelet)                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Hardware Layer                                           ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ GPU Cards (NVIDIA/AMD)                                ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ FPGA Accelerators                                     ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Network Devices (SR-IOV)                              ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ Storage Devices (NVMe)                                ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ Custom Hardware (HashFoundry devices)                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üéØ **Best Practices –¥–ª—è Device Plugins:**

### **1. –†–∞–∑—Ä–∞–±–æ—Ç–∫–∞ Device Plugins:**
- –†–µ–∞–ª–∏–∑—É–π—Ç–µ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ gRPC –º–µ—Ç–æ–¥—ã (ListAndWatch, Allocate)
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ health monitoring –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤
- –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ NUMA topology awareness –¥–ª—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
- –†–µ–∞–ª–∏–∑—É–π—Ç–µ graceful shutdown –∏ cleanup –ø—Ä–æ—Ü–µ–¥—É—Ä—ã

### **2. Deployment –∏ Operations:**
- –†–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–π—Ç–µ device plugins –∫–∞–∫ DaemonSet –Ω–∞ –≤—Å–µ—Ö —É–∑–ª–∞—Ö —Å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º–∏
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ nodeSelector –¥–ª—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è deployment —Ç–æ–ª—å–∫–æ –Ω–∞ —É–∑–ª—ã —Å hardware
- –ù–∞—Å—Ç—Ä–æ–π—Ç–µ proper RBAC permissions –¥–ª—è device plugin pods
- –ú–æ–Ω–∏—Ç–æ—Ä—å—Ç–µ device plugin health –∏ registration status

### **3. –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å:**
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –ø—Ä–∏–≤–∏–ª–µ–≥–∏–∏ –¥–ª—è device plugin containers
- –û–≥—Ä–∞–Ω–∏—á—å—Ç–µ –¥–æ—Å—Ç—É–ø –∫ device files —á–µ—Ä–µ–∑ proper permissions
- –í–∞–ª–∏–¥–∏—Ä—É–π—Ç–µ device allocation requests
- –õ–æ–≥–∏—Ä—É–π—Ç–µ –≤—Å–µ device operations –¥–ª—è –∞—É–¥–∏—Ç–∞

### **4. –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏ –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç—å:**
- –û–ø—Ç–∏–º–∏–∑–∏—Ä—É–π—Ç–µ device discovery –∏ health check intervals
- –†–µ–∞–ª–∏–∑—É–π—Ç–µ efficient device allocation algorithms
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ device topology information –¥–ª—è NUMA-aware scheduling
- –ù–∞—Å—Ç—Ä–æ–π—Ç–µ proper resource limits –¥–ª—è device plugin pods

### **5. –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ troubleshooting:**
- –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–π—Ç–µ device plugin metrics –≤ Prometheus
- –ù–∞—Å—Ç—Ä–æ–π—Ç–µ –∞–ª–µ—Ä—Ç—ã –¥–ª—è device failures –∏ allocation issues
- –õ–æ–≥–∏—Ä—É–π—Ç–µ device allocation –∏ deallocation events
- –ú–æ–Ω–∏—Ç–æ—Ä—å—Ç–µ device utilization –∏ performance metrics

**Device Plugins ‚Äî —ç—Ç–æ –º–æ—â–Ω—ã–π –º–µ—Ö–∞–Ω–∏–∑–º –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ hardware –≤ Kubernetes –∫–ª–∞—Å—Ç–µ—Ä —Å –ø–æ–ª–Ω–æ–π –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π scheduling, isolation –∏ monitoring!**
